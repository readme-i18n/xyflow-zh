---

sidebarTitle: 迁移至 v10
description: 使用本指南从 React Flow v9 迁移至 v10。
---

# 迁移至 React Flow v10

import { Callout } from 'nextra/components';

<Callout type="info">
  旧版 React Flow 文档可在此查看：
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

欢迎使用 React Flow v10！本次主版本更新带来了诸多新特性，同时也包含一些破坏性变更。

## 新特性

- [**子流程**](/learn/layouting/sub-flows): 现在可以将节点添加到父节点中,创建分组和嵌套流程
- **'group'节点类型**: 一种不带连接点的新节点类型,可用作分组节点
- **触摸设备支持**: 现在可以在触摸设备上连接节点
- **初始化时适配视图**: 可使用新的 `fitView` 属性适配初始视图
- **按键处理**: 现在不仅支持单键,还支持多键和组合键操作
- [**useKeyPress钩子**](/api-reference/hooks/use-key-press): 用于处理键盘事件的实用钩子
- [**useReactFlow钩子**](/api-reference/hooks/use-react-flow): 返回一个React Flow实例,提供操作流程的各种函数
- **[useNodes](/api-reference/hooks/use-nodes)、[useEdges](/api-reference/hooks/use-edges)和[useViewport](/api-reference/hooks/use-viewport)钩子**: 用于获取节点、边和视口的钩子
- **边标记**: 更多配置边起始和结束标记的选项

## 重大变更

简要说明:

- 将 `elements` 数组拆分为 `nodes` 和 `edges` 数组，并实现 `onNodesChange` 和 `onEdgesChange` 处理函数（详细指南见[核心概念章节](/learn/concepts/core-concepts)）
- 对自定义的 `nodeTypes` 和 `edgeTypes` 进行记忆化处理
- 将 `onLoad` 重命名为 `onInit`
- 将 `paneMoveable` 重命名为 `panOnDrag`
- 将 `useZoomPanHelper` 重命名为 `useReactFlow`（同时将 `setTransform` 改为 `setViewport`）
- 将节点和边的选项 `isHidden` 重命名为 `hidden`

重大变更的详细说明：

### 1. ~~Elements~~ - 节点与边

我们发现许多开发者对半受控的 `elements` 属性感到困惑。将本地用户状态与 React Flow 内部状态同步总是有些混乱。部分开发者使用了从未正式文档化的内部存储方案，这始终是一种临时解决方案。在新版本中，我们提供了两种使用 React Flow 的方式——非受控模式与受控模式。

### 1.1. 受控的 `nodes` 和 `edges`

若需完全掌控并使用本地状态或存储中的节点(node)和边(edge)，可结合使用 `nodes`、`edges` 属性与 `onNodesChange` 和 `onEdgesChange` 处理器。要实现交互式流程图（若仅需平移缩放则无需实现），需自行处理这些变更事件。当节点被初始化、拖拽、选中或删除时，您将收到变更通知，这意味着您始终能获取节点的精确位置、尺寸或选中状态等数据。我们提供了辅助函数 `applyNodeChanges` 和 `applyEdgeChanges` 来帮助应用这些变更。

#### 旧版 API

```jsx
import { useState, useCallback } from 'react';
import { ReactFlow, removeElements, addEdge } from 'react-flow-renderer';

const initialElements = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
  { id: 'e1-2', source: '1', target: '2' },
];

const BasicFlow = () => {
  const [elements, setElements] = useState(initialElements);
  const onElementsRemove = useCallback(
    (elementsToRemove) =>
      setElements((els) => removeElements(elementsToRemove, els)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setElements((es) => addEdge(connection, es)),
  );

  return (
    <ReactFlow
      elements={elements}
      onElementsRemove={onElementsRemove}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

#### 新版 API

```jsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'react-flow-renderer';

const initialNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  const [nodes, setNodes] = useState(initialNodes);
  const [edges, setEdges] = useState(initialEdges);

  const onNodesChange = useCallback(
    (changes) => setNodes((ns) => applyNodeChanges(changes, ns)),
    [],
  );
  const onEdgesChange = useCallback(
    (changes) => setEdges((es) => applyEdgeChanges(changes, es)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setEdges((eds) => addEdge(connection, eds)),
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

也可使用新 Hook `useNodesState` 和 `useEdgesState` 快速入门：

```js
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
```

相关变更：

- `onElementsClick` 变更为 `onNodeClick` 和 `onEdgeClick`
- `onElementsRemove` 由 `onNodesChange` 和 `onEdgesChange` 处理器替代

### 1.2 非受控模式 `defaultNodes` 与 `defaultEdges`

最简单的入门方式是使用 `defaultNodes` 和 `defaultEdges` 属性。设置这些属性后，所有操作将在内部处理，无需额外添加处理器即可获得完整交互功能（包括拖拽节点、连接节点及删除节点/边）：

#### 新版 API

```jsx
import ReactFlow from 'react-flow-renderer';

const defaultNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const defaultEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  return <ReactFlow defaultNodes={defaultNodes} defaultEdges={defaultEdges} />;
};

export default BasicFlow;
```

若需添加、移除或更新节点/边，只能通过 [ReactFlow 实例](/api-reference/types/react-flow-instance) 进行操作。该实例可通过新的 `useReactFlow` 钩子获取，或通过接收实例作为参数的 `onInit` 处理函数获得。

### 2. 缓存自定义的 `nodeTypes` 和 `edgeTypes`

每当传入新的节点或边类型时，系统会在后台创建封装后的组件类型。这意味着**不应在每次渲染时创建新的 `nodeType` 或 `edgeType` 对象**。请缓存这些类型，或在类型不变时将其定义在组件外部。

**错误示范：**

以下写法会在每次渲染时创建新对象，导致错误和性能问题：

```jsx
// this is bad! Don't do it.
<ReactFlow
  nodes={[]}
  nodeTypes={{
    specialType: SpecialNode, // bad!
  }}
/>
```

**正确做法：**

```jsx
function Flow() {
  const nodeTypes = useMemo(() => ({ specialType: SpecialNode }), []);

  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

或在类型不变时将其定义在组件外部：

```jsx
const nodeTypes = { specialType: SpecialNode };

function Flow() {
  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

### 3. ~~Redux~~ - Zustand

我们已将状态管理库从 Redux 迁移至 [Zustand](https://github.com/pmndrs/zustand)。此变更减少了约 300 行状态相关代码。如需访问内部存储，可使用 [`useStore` 钩子](/api-reference/hooks/use-store)：

#### 旧版 API

```jsx
import { useStoreState, useStoreActions } from 'react-flow-renderer';

...

const transform = useStoreState((store) => store.transform);
```

#### 新版 API

```jsx
import { useStore } from 'react-flow-renderer';

...
const transform = useStore((store) => store.transform);
```

如需访问内部存储，仍需用 `<ReactFlowProvider />` 包裹组件。

我们还导出了 `useStoreApi`，以便您可以在事件处理程序中获取 store 而不会触发重新渲染。

```js
import { useStoreApi } from 'react-flow-renderer';

...

const store = useStoreApi();

...
// in an event handler
const [x, y, zoom] = store.getState().transform;
```

### 4. ~~onLoad~~ - onInit

`onLoad` 回调已重命名为 `onInit`，现在会在节点初始化时触发。

#### 旧版 API

```jsx
const onLoad = (reactFlowInstance: OnLoadParams) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onLoad={onLoad}
/>
```

#### 新版 API

```jsx
const onInit = (reactFlowInstance: ReactFlowInstance) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onInit={onInit}
/>
```

### 5. ~~paneMoveable~~ - panOnDrag

这与其他 API 更加一致（如 `panOnScroll`、`zoomOnScroll` 等）

#### 旧版 API

```jsx
<ReactFlow
   ...
  paneMoveable={false}
/>
```

#### 新版 API

```jsx
<ReactFlow
   ...
  panOnDrag={false}
/>
```

### 6. ~~useZoomPanHelper transform~~ - 统一整合至 `useReactFlow`

由于 "transform" 也是 store 中变换操作的变量名，且 `transform` 作为设置器不够明确，我们将其重命名为 `setViewport`。这与其他函数也更加一致。此外，所有 `useZoomPanHelper` 函数都已迁移至 [React Flow 实例](/api-reference/types/react-flow-instance)，您可以通过 [`useReactFlow` 钩子](/api-reference/hooks/use-react-flow) 或 `onInit` 处理程序获取该实例。

#### 旧版 API

```js
const { transform, setCenter, setZoom  } = useZoomPanHelper();
...
transform({ x: 100, y: 100, zoom: 2 });
```

#### 新版 API

```js
const { setViewport, setCenter, setZoom } = useReactFlow();
...
setViewport({ x: 100, y: 100, zoom: 2 });
```

新增视口函数：

- `getZoom`
- `getViewport`

### 7. ~~isHidden~~ - hidden

我们统一了布尔型选项的命名规范，不再混用前缀式（`is...`）和非前缀式命名。所有节点和边的选项现在均采用非前缀形式，如 `hidden`、`animated`、`selected`、`draggable`、`selectable` 和 `connectable`。

#### 旧版 API

```js
const hiddenNode = { id: '1', isHidden: true, position: { x: 50, y: 50 } };
```

#### 新版 API

```js
const hiddenNode = { id: '1', hidden: true, position: { x: 50, y: 50 } };
```

### 8. ~~arrowHeadType~~ ~~markerEndId~~ - markerStart / markerEnd

我们改进了用于自定义边线标记的 API。通过新 API，您可以在边线的起点和终点设置独立的标记，并自定义颜色、描边宽度等属性。您仍然可以使用 `markerEndId`，但现在 `markerStart` 和 `markerEnd` 属性不仅支持传入字符串（需自行定义的 SVG 标记 ID），还支持配置对象以使用内置的 `arrowClosed` 或箭头标记。

#### 旧版 API

```js
const markerEdge = { source: '1', target: '2', arrowHeadType: 'arrow' };
```

#### 新版 API

```js
const markerEdge = {
  source: '1',
  target: '2',
  markerStart: 'myCustomSvgMarker',
  markerEnd: { type: 'arrow', color: '#f00' },
};
```

### 9. ~~ArrowHeadType~~ - MarkerType

此为术语统一调整：由于现在支持为边线起点设置标记，原 `ArrowHeadType` 类型已更名为 `MarkerType`。未来该类型不仅支持箭头形状，还将支持圆形、菱形等其他形状。

### 10. 版权声明

这并非 API 的重大变更，而是 React Flow 外观的细微调整。我们在右下角添加了小型 "React Flow" 版权声明（位置可通过 `attributionPosition` 属性配置）。此变更是新推出的 "React Flow Pro" 订阅模式的一部分。如需在商业应用中移除该声明，请订阅 ["React Flow Pro"](/pro)。