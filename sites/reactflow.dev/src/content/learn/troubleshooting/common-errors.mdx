---

description: React Flow 常见问题排查与修复方法
---

# 常见错误

import { Callout } from 'nextra/components';

本指南包含使用 React Flow 时可能出现的警告和错误。我们还整理了来自
[Discord 社区](https://discord.gg/RVmnytFmGW)、
[GitHub Issues](https://github.com/xyflow/xyflow/issues) 和
[GitHub Discussions](https://github.com/xyflow/xyflow/discussions) 的常见问题与易错点。

<div id="001" />

### 警告：检测到未使用 zustand provider 作为祖先组件

通常由以下情况导致：

**情况A:** 安装了多个不同版本的 @reactflow/core<br /> **情况B:** 尝试在 React Flow 上下文之外访问其内部状态

#### 情况A解决方案

更新 reactflow 和 @reactflow/node-resizer（如使用），删除 node_modules 和 package-lock.json 后重新安装依赖。

#### 情况B解决方案

可用方案包括：使用 [`<ReactFlowProvider />`](/api-reference/react-flow-provider) 包裹组件，或将访问状态的代码移至 React Flow 实例的子组件中。

<Callout type="error">这将导致错误：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function FlowWithoutProvider(props) {
  // cannot access the state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

export default FlowWithoutProvider;
```

<Callout type="error">同样会导致错误：</Callout>

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // still cannot access the state here
  // only child components of this component can access the state
  const reactFlowInstance = useReactFlow();

  return (
    <ReactFlowProvider>
      <ReactFlow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<Callout type="info">此方案有效：</Callout>

当你需要访问 React Flow 的内部状态时（例如使用 `useReactFlow` 钩子），必须用 `<ReactFlowProvider />` 包裹你的组件。这里的包裹操作是在组件外部完成的：

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // you can access the internal state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

// wrapping with ReactFlowProvider is done outside of the component
function FlowWithProvider(props) {
  return (
    <ReactFlowProvider>
      <Flow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<div id="002" />

### 检测到新建了 nodeTypes 或 edgeTypes 对象

若非有意为之，请将 nodeTypes/edgeTypes 定义在组件外部或进行记忆化处理。

当 `nodeTypes` 或 `edgeTypes` 属性在初始渲染后发生变化时会出现此警告。除非极特殊情况，否则这些类型定义应保持静态。通常它们只需定义一次，包含应用中使用的所有类型。常见情况是在组件渲染函数内部定义 nodeTypes 或 edgeTypes 对象，这将导致每次组件重新渲染时 React Flow 都会跟着重新渲染。

<Callout type="error">会触发警告的写法：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  // new object being created on every render
  // causing unnecessary re-renders
  const nodeTypes = {
    myCustomNode: MyCustomNode,
  };

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">推荐实现方式：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import MyCustomNode from './MyCustomNode';

// defined outside of the component
const nodeTypes = {
  myCustomNode: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">替代实现方案：</Callout>

若需动态变更 nodeTypes 同时避免不必要的重新渲染，可采用此方案。

```jsx
import { useMemo } from 'react';
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  const nodeTypes = useMemo(
    () => ({
      myCustomNode: MyCustomNode,
    }),
    [],
  );

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<div id="003" />

### 未找到节点类型，将使用默认类型 "default"

这种情况通常发生在您为某个节点指定了自定义节点类型，但未向 React Flow 传递正确的 nodeTypes 属性时。自定义节点的 type 选项字符串必须与 nodeTypes 对象的键名完全一致。

<Callout type="error">无效示例：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

function Flow(props) {
  // nodeTypes property is missing, so React Flow cannot find the custom node component to render
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="error">同样无效：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  Custom: MyCustomNode,
};

function Flow(props) {
  // node.type and key in nodeTypes object are not exactly the same (capitalized)
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<Callout type="info">有效示例：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  custom: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<div id="004" />

### React Flow 父容器需要设置宽度和高度才能渲染图表

React Flow 底层会测量父级 DOM 元素的尺寸来调整渲染器。如果您尝试在没有高度的普通 div 中渲染 React Flow，我们将无法显示图表。若遇到此警告，请确保为包裹组件添加 CSS 样式，使其具有固定高度或继承父级高度。

<Callout type="error">会触发警告的配置：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  return (
    <div>
      <ReactFlow {...props} />
    </div>
  );
}
```

<Callout type="info">正常工作的示例：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

function Flow(props) {
  return (
    <div style={{ height: 800 }}>
      <ReactFlow {...props} />
    </div>
  );
}
```

<div id="005" />

### 仅子节点可使用父级范围限制

当您尝试为没有父节点的节点添加 `extent` 选项时会出现此警告。根据实际需求，您可以移除 `extent` 选项或指定 `parentNode`。

<Callout type="error">会显示警告的情况：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  {
    id: 'mycustomnode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="info">解决警告的方案：</Callout>

```jsx import { ReactFlow } from '@xyflow/react';
const nodes = [
  {
    id: 'mycustomnode',
    parentNode: 'someothernode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<div id="006" />

### 无法创建边。边必须包含源节点和目标节点。

这种情况发生在未向边对象传递 `source` 和 `target` 选项时。缺少源节点和目标节点信息，边将无法被渲染。

<Callout type="error">会显示警告：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  /* ... */
];

const edges = [
  {
    nosource: '1',
    notarget: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<Callout type="info">以下方式有效：</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

const nodes = [
  /* ... */
];

const edges = [
  {
    source: '1',
    target: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<div id="007" />

### 旧边 id="some-id" 不存在

当尝试[重新连接边](/examples/edges/reconnect-edge)时可能出现此问题，但需更新的边已从状态中移除。这种情况非常罕见，具体实现请参阅[重新连接边示例](/examples/edges/reconnect-edge)。

<div id="008" />

### 无法为源/目标手柄 id: "some-id" 创建边；边 id: "some-id"

当使用多个手柄且未通过 `id` 属性找到对应手柄，或未通过编程方式[在添加/移除手柄后更新节点内部状态](/api-reference/hooks/use-update-node-internals)时会出现此问题。多手柄操作示例请见[自定义节点示例](/examples/nodes/custom-node)。

<div id="009" />

### 标记类型不存在

当尝试指定 React Flow 内置不支持的标记类型时会触发此警告。现有标记类型文档参见[此处](/api-reference/types/edge#edgemarker)。

<div id="010" />

### 手柄：未找到节点 id

此警告发生在自定义节点组件外部使用 `<Handle />` 组件时。

### 使用 webpack 4 构建应用时出现错误

如果您使用 webpack 4，很可能会遇到如下错误：

```
ERROR in /node_modules/@reactflow/core/dist/esm/index.js 16:19
Module parse failed: Unexpected token (16:19)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
```

React Flow 采用现代 JavaScript 代码库，使用了大量新特性。默认情况下，webpack 4 不会转译代码，因此无法正确处理 React Flow。

您需要在 webpack 配置中添加以下 babel 插件才能使其正常工作：

```sh npm2yarn copy
npm i --save-dev babel-loader@8.2.5 @babel/preset-env @babel/preset-react @babel/plugin-proposal-optional-chaining @babel/plugin-proposal-nullish-coalescing-operator
```

并按如下方式配置加载器：

```js
{
  test: /node_modules[\/\\]@?reactflow[\/\\].*.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env', "@babel/preset-react"],
      plugins: [
        "@babel/plugin-proposal-optional-chaining",
        "@babel/plugin-proposal-nullish-coalescing-operator",
      ]
    }
  }
}
```

<Callout type="info">
  如果使用 webpack 5，则无需任何操作！React Flow 可直接运行。
</Callout>

### 当节点包含 `<canvas />` 元素时鼠标事件响应不一致

如果在自定义节点中使用 `<canvas />` 元素，可能会遇到画布鼠标事件坐标计算异常的问题。

React Flow 使用 CSS 变换来实现缩放功能，但从 DOM 视角看元素实际尺寸并未改变。如果您的事件监听器需要计算相对于画布元素的鼠标位置，这会导致问题。

解决方案是在您控制的事件处理器中，将计算得到的相对位置乘以 `1 / zoom`（其中 `zoom` 是当前流程图缩放级别）。可通过 [`useReactFlow`](/api-reference/hooks/use-react-flow) 钩子的 `getZoom` 方法获取当前缩放值。

### 边线未显示

如果在 React Flow 中无法显示边线，可能是以下原因之一导致的：

- 未导入 React Flow 样式表。如需导入，可使用 `import '@xyflow/react/dist/style.css';` 语句。
- 若使用自定义节点替换了默认节点，请检查该自定义节点组件是否包含正确的 `source/target` 连接手柄。缺少手柄将无法创建边线。
- 若使用 Tailwind 或 Bulma 等外部样式库，请确保其未覆盖边线样式。例如，某些样式库会通过 `overflow: hidden` 覆盖 `.react-flow__edges` SVG 选择器，导致边线隐藏。
- 若涉及异步操作（如后端请求），务必在操作完成后调用 [`useUpdateNodeInternal`](/api-reference/hooks/use-update-node-internals) 钩子返回的 `updateNodeInternals` 函数，以便 React Flow 内部更新手柄位置。

### 边线显示异常

若边线未能正确渲染，可能由以下原因引起：

- 如需隐藏连接点(handle)，请勿使用 `display: none`，应改用 `opacity: 0` 或 `visibility: hidden`
- 若边(edge)未正确连接到目标连接点，请检查自定义节点组件中是否包含多个同类型连接点（`source` 或 `target`）。若存在此情况，需为它们分配唯一ID。同一节点上的同类型连接点必须具有可区分的ID，以便React Flow识别边对应的连接点
- 当调整连接点位置（如重新排序等操作）后，务必调用 [`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) 钩子返回的 `updateNodeInternals` 函数，通知React Flow更新内部连接点位置
- 使用自定义边时，若需实现从源连接点到目标连接点的路径，请确保在边路径创建函数（如 [`getBezierPath`](/api-reference/utils/get-bezier-path)）中正确传递自定义边组件提供的 `sourceX, sourceY, targetX, targetY` 属性。这些属性分别表示源/目标连接点的x,y坐标
- 若自定义边的源端或目标端未按预期指向连接点（出现异常角度进出），请确保在边路径创建函数（如 [`getBezierPath`](/api-reference/utils/get-bezier-path)）中传递自定义边组件提供的 `sourcePosition` 和 `targetPosition` 属性。这些连接点位置参数对边的正确起始/终止至关重要