---

sidebarTitle: Mind Map App
title: 使用 React Flow 构建思维导图应用
intro: "本教程将指导您使用 React Flow 创建一个简单的思维导图工具，可用于头脑风暴、整理想法或以可视化方式映射思维。我们将运用状态管理、自定义节点与连线等技术来构建这个应用。"
date: 2023/01/10
authors: ['moritz']
tags: ['react-flow', 'how-to', 'mind-map']
image: /img/tutorials/mindmap/mindmap.png
---

import { Emoji } from '@xyflow/xy-ui';
import { RemoteCodeViewer } from 'xy-shared/server';

本教程将指导您使用 React Flow 创建一个简单的思维导图工具，可用于头脑风暴、整理想法或以可视化方式映射思维。我们将运用状态管理、自定义节点与连线等技术来构建这个应用。

## <Emoji content="🎬" /> 演示时间到！

在开始动手之前，先展示本教程最终将实现的思维导图工具：

<RemoteCodeViewer route="tutorials/mindmap/app" framework="react"  />

如果您想直接体验代码，可以在 [Github](https://github.com/xyflow/react-flow-mindmap-app) 上查看源代码。

## <Emoji content="👩🏻‍💻" /> 准备工作

学习本教程需要具备 [React](https://reactjs.org/docs/getting-started.html) 和 [React Flow](/learn/concepts/terms-and-definitions) 的基础知识（没错就是我们！<Emoji content="😁" /> 这是一个用于构建基于节点UI的开源库，可开发工作流工具、ETL管道等[更多应用](/showcase/)）。

我们将使用 [Vite](https://vitejs.dev/) 来开发应用，但你也可以选择 [Create React App](https://create-react-app.dev/) 或其他任何喜欢的工具。要使用 Vite 搭建新的 React 应用，你需要执行以下操作：

```bash npm2yarn
npm create vite@latest reactflow-mind-map -- --template react
```

如果你想使用 TypeScript：

```bash npm2yarn
npm create vite@latest reactflow-mind-map -- --template react-ts
```

完成初始设置后，需要安装一些依赖包：

```bash npm2yarn
npm install reactflow zustand classcat nanoid
```

我们使用 [Zustand](https://github.com/pmndrs/zustand) 来管理应用状态。它类似于 Redux，但体积更小且需要编写的样板代码更少。React Flow 同样采用 Zustand，因此安装时不会产生额外开销。（本教程使用 TypeScript，但你也可以使用原生 JavaScript。）

为保持简洁，我们将所有代码放在 `src/App` 文件夹中。为此你需要创建该文件夹，并添加包含以下内容的索引文件：

#### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel } from '@xyflow/react';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

function Flow() {
  return (
    <ReactFlow>
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

这将成为我们渲染思维导图的主组件。虽然尚未添加任何节点或边，但我们已加入 React Flow 的 [`Controls`](/api-reference/components/controls) 组件和用于显示应用标题的 [`Panel`](/api-reference/components/panel)。

要使用 React Flow 的钩子函数，我们需要在 main.tsx（Vite 的入口文件）中用 [`ReactFlowProvider`](/api-reference/react-flow-provider) 组件包裹应用。同时导入新创建的 `App/index.tsx` 并将其渲染在 `ReactFlowProvider` 内部。主文件应如下所示：

#### src/main.tsx

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

import App from './App';

import './index.css';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ReactFlowProvider>
      <App />
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

React Flow 组件的父容器需要设置宽度和高度才能正常工作。由于我们的应用是全屏应用，因此将这些规则添加到 `index.css` 文件中：

#### src/index.css

```css
body {
  margin: 0;
}

html,
body,
#root {
  height: 100%;
}
```

我们将所有应用样式都添加到 `index.css` 文件（也可以使用 [Tailwind](/examples/styling/tailwind)）。现在可以通过 `npm run dev` 启动开发服务器，您应该会看到以下内容：

<RemoteCodeViewer
  route="tutorials/mindmap/getting-started"
  framework="react"
/>

## <Emoji content="🏪" /> 节点与边的存储库

如前所述，我们使用 Zustand 进行状态管理。为此，在 `src/App` 文件夹中创建一个名为 `store.ts` 的新文件：

#### src/App/store.ts

```ts
import {
  Edge,
  EdgeChange,
  Node,
  NodeChange,
  OnNodesChange,
  OnEdgesChange,
  applyNodeChanges,
  applyEdgeChanges,
} from '@xyflow/react';
import { createWithEqualityFn } from 'zustand/traditional';

export type RFState = {
  nodes: Node[];
  edges: Edge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
};

const useStore = createWithEqualityFn<RFState>((set, get) => ({
  nodes: [
    {
      id: 'root',
      type: 'mindmap',
      data: { label: 'React Flow Mind Map' },
      position: { x: 0, y: 0 },
    },
  ],
  edges: [],
  onNodesChange: (changes: NodeChange[]) => {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },
  onEdgesChange: (changes: EdgeChange[]) => {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },
}));

export default useStore;
```

看起来代码量不少，但主要是类型定义 <Emoji content="😇" /> 该存储库负责跟踪节点和边，并处理变更事件。当用户拖动节点时，React Flow 会触发变更事件，存储库随后应用这些变更，并渲染更新后的节点。（更多细节可参阅我们的[状态管理库指南](/api-reference/hooks/use-store)。）

如你所见，我们首先在坐标 `{ x: 0, y: 0 }` 处放置了一个类型为 'mindmap' 的初始节点。为了将状态存储与我们的应用连接，我们使用了 `useStore` 钩子：

#### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel, NodeOrigin } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import useStore, { RFState } from './store';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

const selector = (state: RFState) => ({
  nodes: state.nodes,
  edges: state.edges,
  onNodesChange: state.onNodesChange,
  onEdgesChange: state.onEdgesChange,
});

// this places the node origin in the center of a node
const nodeOrigin: NodeOrigin = [0.5, 0.5];

function Flow() {
  // whenever you use multiple values, you should use shallow to make sure the component only re-renders when one of the values changes
  const { nodes, edges, onNodesChange, onEdgesChange } = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      nodeOrigin={nodeOrigin}
      fitView
    >
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

我们从存储中获取节点、边和变更处理器，并将它们传递给 React Flow 组件。我们还使用了 `fitView` 属性确保初始节点在视图中居中显示，并通过设置节点原点为 `[0.5, 0.5]` 将原点定位在节点中心。完成这些后，你的应用应该呈现如下效果：

<RemoteCodeViewer route="tutorials/mindmap/store-nodes-edges" framework="react" />

现在你可以拖动节点并缩放视图，我们已经取得了一些进展 <Emoji content="🚀" /> 接下来让我们添加更多功能。

## <Emoji content="✨" /> 自定义节点与边

我们需要为节点使用名为 'mindmap' 的自定义类型。为此需要添加一个新组件。让我们在 `src/App` 下创建一个名为 `MindMapNode` 的文件夹，并在其中添加包含以下内容的 index 文件：

#### src/App/MindMapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  return (
    <>
      <input defaultValue={data.label} />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
    </>
  );
}

export default MindMapNode;
```

我们使用输入框来显示和编辑思维导图节点的标签，并通过两个连接点（handle）实现节点间的连接。这是 React Flow 正常工作所必需的——这些连接点将作为边的起点和终点位置。

我们还在 `index.css` 文件中添加了一些 CSS 样式让节点看起来更美观：

#### src/index.css

```css
.react-flow__node-mindmap {
  background: white;
  border-radius: 2px;
  border: 1px solid transparent;
  padding: 2px 5px;
  font-weight: 700;
}
```

（更多相关内容可查阅文档中的[自定义节点指南](/learn/customization/custom-nodes)）

让我们为自定义边做同样的处理。在 `src/App` 下新建一个名为 `MindMapEdge` 的文件夹，并创建索引文件：

#### src/App/MindMapEdge/index.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

关于自定义节点和边的更多细节将在下一节展开。现在关键是通过以下修改让我们的应用能使用新类型：

```tsx
import MindMapNode from './MindMapNode';
import MindMapEdge from './MindMapEdge';

const nodeTypes = {
  mindmap: MindMapNode,
};

const edgeTypes = {
  mindmap: MindMapEdge,
};
```

然后将新创建的类型传递给 React Flow 组件。

<RemoteCodeViewer route="tutorials/mindmap/custom-nodes-edges" framework="react" />

很好！现在我们已经可以通过点击输入框并输入文本来修改节点标签了。

## <Emoji content="🆕" /> 新建节点

我们希望让用户能极速创建新节点。用户应该能够通过点击现有节点并拖拽到目标位置来添加新节点。这个功能并非 React Flow 内置，但我们可以利用 [`onConnectStart` 和 `onConnectEnd`](/api-reference/react-flow#onconnectstart) 处理器来实现。

我们使用 start 处理器记录被点击的节点，用 end 处理器创建新节点：

#### 添加到 src/App/index.tsx

```tsx
const connectingNodeId = useRef<string | null>(null);

const onConnectStart: OnConnectStart = useCallback((_, { nodeId }) => {
  connectingNodeId.current = nodeId;
}, []);

const onConnectEnd: OnConnectEnd = useCallback((event) => {
  // we only want to create a new node if the connection ends on the pane
  const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');

  if (targetIsPane && connectingNodeId.current) {
    console.log(`add new node with parent node ${connectingNodeId.current}`);
  }
}, []);
```

由于节点由状态库管理，我们创建一个动作来添加新节点及其连接边。`addChildNode` 动作的实现如下：

#### src/store.ts 中的新动作

```ts
addChildNode: (parentNode: Node, position: XYPosition) => {
  const newNode = {
    id: nanoid(),
    type: 'mindmap',
    data: { label: 'New Node' },
    position,
    parentNode: parentNode.id,
  };

  const newEdge = {
    id: nanoid(),
    source: parentNode.id,
    target: newNode.id,
  };

  set({
    nodes: [...get().nodes, newNode],
    edges: [...get().edges, newEdge],
  });
};
```

我们将传入的节点作为父节点使用。通常这一功能用于实现[分组](/examples/nodes/dynamic-grouping)或[子流程](/examples/grouping/sub-flows)。在此场景中，我们利用它来实现当父节点移动时同步移动所有子节点。这让我们能够清理和重新组织思维导图，而无需手动移动每个子节点。现在让我们在`onConnectEnd`处理程序中使用这个新动作：

#### 调整 src/App/index.tsx 文件

```tsx
const store = useStoreApi();

const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');

    if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

首先通过`store.getState()`从React Flow存储中获取`nodeLookup`。`nodeLookup`是一个包含所有节点及其当前状态的映射表，我们需要用它来获取被点击节点的位置和尺寸。接着检查`onConnectEnd`事件的目标是否为React Flow面板，如果是则添加新节点。这里我们使用`addChildNode`方法和新创建的`getChildNodePosition`辅助函数。

#### src/App/index.tsx 中的辅助函数

```tsx
const getChildNodePosition = (event: MouseEvent, parentNode?: Node) => {
  const { domNode } = store.getState();

  if (
    !domNode ||
    // we need to check if these properties exist, because when a node is not initialized yet,
    // it doesn't have a positionAbsolute nor a width or height
    !parentNode?.computed?.positionAbsolute ||
    !parentNode?.computed?.width ||
    !parentNode?.computed?.height
  ) {
    return;
  }

  const panePosition = screenToFlowPosition({
    x: event.clientX,
    y: event.clientY,
  });

  // we are calculating with positionAbsolute here because child nodes are positioned relative to their parent
  return {
    x:
      panePosition.x -
      parentNode.computed?.positionAbsolute.x +
      parentNode.computed?.width / 2,
    y:
      panePosition.y -
      parentNode.computed?.positionAbsolute.y +
      parentNode.computed?.height / 2,
  };
};
```

该函数返回要添加到存储中的新节点位置。我们使用[`project`函数](/api-reference/types/react-flow-instance#project)将屏幕坐标转换为React Flow坐标。如前所述，子节点的位置是相对于其父节点定位的，因此需要从子节点位置中减去父节点位置。这些概念可能有些复杂，让我们通过实际操作来理解：

<RemoteCodeViewer route="tutorials/mindmap/create-nodes" framework="react" />

要测试新功能，您可以从连接点开始拖动，然后在面板上结束连接。此时应该能看到思维导图中新增了一个节点。

## <Emoji content="🤝" /> 保持数据同步

虽然我们已经可以更新节点标签，但尚未同步更新节点数据对象。这对于保持应用状态同步至关重要，例如当我们需要将节点数据保存到服务器时。为此，我们在存储库中添加了一个名为`updateNodeLabel`的新操作，该操作接收节点ID和标签作为参数。实现非常简单：遍历现有节点，用传入的标签更新匹配的节点：

#### src/store.ts

```ts
updateNodeLabel: (nodeId: string, label: string) => {
  set({
    nodes: get().nodes.map((node) => {
      if (node.id === nodeId) {
        // it's important to create a new object here, to inform React Flow about the changes
        node.data = { ...node.data, label };
      }

      return node;
    }),
  });
},
```

现在让我们在`MindmapNode`组件中使用这个新操作：

#### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <input
        // from now on we can use value instead of defaultValue
        // this makes sure that the input always shows the current label of the node
        value={data.label}
        onChange={(evt) => updateNodeLabel(id, evt.target.value)}
        className="input"
      />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

效果立竿见影！自定义节点的输入框现在能正确显示节点当前标签了。您可以获取节点数据，将其保存到服务器，之后再进行加载。

## <Emoji content="💅" /> 优化用户体验与样式

功能层面，我们的思维导图应用已经完成！可以添加新节点、更新标签以及移动节点。但用户体验和样式还有提升空间。让我们优化节点拖拽和创建新节点的操作体验！

### 1. 将整个节点作为拖拽手柄

让我们将整个节点作为连接手柄使用，而不是显示默认的手柄。这样可以更轻松地创建节点，因为可开始新连接的区域变得更大了。我们需要将源手柄样式设置为节点大小，并视觉上隐藏目标手柄。React Flow 仍需要目标手柄来连接节点，但由于我们是通过在面板上拖放边来创建新节点，所以无需显示它。我们使用传统 CSS 来隐藏目标手柄并将其定位在节点中心：

#### src/index.css

```css
.react-flow__handle.target {
  top: 50%;
  pointer-events: none;
  opacity: 0;
}
```

为了使整个节点成为手柄，我们还需要更新源手柄的样式：

#### src/index.css

```css
.react-flow__handle.source {
  top: 0;
  left: 0;
  transform: none;
  background: #f6ad55;
  height: 100%;
  width: 100%;
  border-radius: 2px;
  border: none;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle" framework="react" />

这样虽然可行，但我们现在无法移动节点了，因为源手柄已覆盖整个节点并遮挡了输入框。我们通过使用 [`dragHandle` 节点选项](/api-reference/types/node#drag-handle)来解决这个问题。该选项允许我们指定一个 DOM 元素选择器作为拖拽手柄。为此我们对自定义节点稍作调整：

#### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <div className="inputWrapper">
        <div className="dragHandle">
          {/* icon taken from grommet https://icons.grommet.io */}
          <svg viewBox="0 0 24 24">
            <path
              fill="#333"
              stroke="#333"
              strokeWidth="1"
              d="M15 5h2V3h-2v2zM7 5h2V3H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2z"
            />
          </svg>
        </div>
        <input
          value={data.label}
          onChange={(evt) => updateNodeLabel(id, evt.target.value)}
          className="input"
        />
      </div>

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

我们添加了一个带有 `inputWrapper` 类名的包装 div，以及一个作为拖拽手柄的 `dragHandle` 类名 div（惊喜！）。现在我们可以为这些新元素添加样式：

#### src/index.css

```css
.inputWrapper {
  display: flex;
  height: 20px;
  z-index: 1;
  position: relative;
}

.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
}

.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-2" framework="react" />

### 2. 聚焦时激活输入

我们即将完成，但还需要调整一些细节。我们希望从节点的中心开始建立新连接。为此，我们将输入的指针事件设置为"none"，并检查用户是否在节点上方释放按钮。只有在这种情况下，我们才希望激活输入字段。我们可以利用`onConnectEnd`函数来实现这一点：

#### src/App/index.tsx

```tsx
const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');
    const node = (event.target as Element).closest('.react-flow__node');

    if (node) {
      node.querySelector('input')?.focus({ preventScroll: true });
    } else if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

如你所见，当用户在节点上方释放鼠标按钮时，我们会聚焦输入字段。现在我们可以添加一些样式，使得输入字段仅在获得焦点时激活（pointerEvents: all）：

```css
/* we want the connection line to be below the node */
.react-flow .react-flow__connectionline {
  z-index: 0;
}

/* pointer-events: none so that the click for the connection goes through */
.inputWrapper {
  display: flex;
  height: 20px;
  position: relative;
  z-index: 1;
  pointer-events: none;
}

/* pointer-events: all so that we can use the drag handle (here the user cant start a new connection) */
.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
  pointer-events: all;
}

/* pointer-events: none by default */
.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
  pointer-events: none;
}

/* pointer-events: all when it's focused so that we can type in it */
.input:focus {
  border: none;
  outline: none;
  background: rgba(255, 255, 255, 0.25);
  pointer-events: all;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-3" framework="react" />

### 3. 动态宽度与自动聚焦

快完成了！我们希望根据文本长度实现节点的动态宽度。为简化操作，我们将基于文本长度进行计算：

#### 在src/app/MindMapNode.tsx中添加的效果

```jsx
useLayoutEffect(() => {
  if (inputRef.current) {
    inputRef.current.style.width = `${data.label.length * 8}px`;
  }
}, [data.label.length]);
```

我们还希望在节点创建后立即聚焦/激活它：

#### 在src/app/MindMapNode.tsx中添加的效果

```jsx
useEffect(() => {
  setTimeout(() => {
    if (inputRef.current) {
      inputRef.current.focus({ preventScroll: true });
    }
  }, 1);
}, []);
```

<RemoteCodeViewer
  route="tutorials/mindmap/node-as-handle-4"
  framework="react"
  activeFile="MindMapNode.tsx"
/>

现在当你调整节点标签时，节点的宽度会相应变化。你也可以创建新节点，它会立即获得焦点。

### 4. 居中的边线与样式细节

你可能已经注意到边线没有居中。我们最初为此创建了自定义边线，现在可以稍作调整，使边线从节点中心而非手柄顶部（默认行为）开始：

#### src/App/MindMapEdge.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY: sourceY + 20,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

我们将所有属性传递给 [`getStraightPath`](/api-reference/utils/get-straight-path) 辅助函数，但调整了 sourceY 使其位于节点中心位置。

此外，我们希望标题更加低调，并为背景选择一种颜色。可以通过调整面板颜色（我们添加了类名 `"header"`）和 body 元素的背景色来实现：

```css
body {
  margin: 0;
  background-color: #f8f8f8;
  height: 100%;
}

.header {
  color: #cdcdcd;
}
```

干得漂亮！<Emoji content="💯" /> 最终代码可在此处查看：

<RemoteCodeViewer
  route="tutorials/mindmap/node-as-handle-4"
  framework="react"
  activeFile="MindMapNode.tsx"
/>

## <Emoji content="👋" /> 最终总结

多么精彩的旅程！我们从空白面板开始，最终完成了一个功能齐全的思维导图应用。如果想继续完善，可以考虑以下功能：

- 通过点击面板添加新节点
- 保存和恢复按钮，将当前状态存储到本地存储
- 导出和导入界面
- 协同编辑功能

希望你喜欢本教程并学到新知识！如有任何问题或反馈，欢迎通过 [Twitter](https://twitter.com/moklick) 联系我，或加入我们的 [Discord 服务器](https://discord.com/invite/RVmnytFmGW)。React Flow 是由用户资助的独立公司，若想支持我们，可以 [在 Github 赞助](https://github.com/sponsors/xyflow) 或 [订阅我们的 Pro 计划](/pro/)。