---

sidebarTitle: Slideshow App
title: 使用 React Flow 创建幻灯片演示
intro: 
  我们近期利用 React Flow 发布了 2023 年度调查结果。本教程将分享我们的经验，并展示如何构建类似效果！
date: 2024/01/07
authors: ['hayleigh']
tags: ['react-flow', 'presentation', 'slide-show']
image: /img/tutorials/presentation/slideshow-thumb.png
---

import { Emoji } from '@xyflow/xy-ui';
import { Callout, Cards } from 'nextra/components';
import { Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

我们最近通过 [交互式演示](/developer-survey-2023) 发布了 React Flow 2023 年度调查的关键发现，该演示正是使用 React Flow 构建的。这个幻灯片应用包含许多实用功能，因此我们希望分享其实现方法！

<Image
  src="/img/tutorials/presentation/survey.png"
  caption="Our 2023 end of year survey app was made up of many static nodes and buttons to navigate between them."
  alt="Screenshot of slides laid out on an infinite canvas, each with information pulled from a survey of React Flow users"
/>

完成本教程后，您将构建一个具备以下功能的演示应用：

- 支持 Markdown 幻灯片
- 视口键盘导航
- 自动布局
- 点击拖拽平移导航（类似 Prezi）

过程中您将学习布局算法基础、创建静态流程图以及自定义节点。

最终效果如下图所示！

<RemoteCodeViewer route="tutorials/presentation/app" framework="react" />

学习本教程需要具备 [React](https://reactjs.org/docs/getting-started.html) 和 [React Flow](/learn/concepts/terms-and-definitions) 的基础知识。如遇问题，欢迎通过 [Discord](https://discord.com/invite/RVmnytFmGW) 联系我们！

这里是[最终代码的仓库](https://github.com/xyflow/react-flow-slide-show)，如果你想跳过步骤或随时参考。

让我们开始吧！

## 项目初始化

我们推荐在新 React Flow 项目中使用 [Vite](https://vitejs.dev)，这次我们还会加入 TypeScript。可以通过以下命令创建新项目：

```bash npm2yarn
npm create vite@latest -- --template react-ts
```

如果更倾向使用 JavaScript，可以改用 `react` 模板。你也可以直接在浏览器中通过我们的 Codesandbox 模板跟随教程：

<Cards num={2}>
  <Cards.Card
    title="new.reactflow.dev/js"
    href="https://new.reactflow.dev/js"
    icon={
      <div className="rounded-full w-10 h-10 bg-yellow-200 text-gray-700 font-black flex items-center justify-center">
        JS
      </div>
    }
  />
  <Cards.Card
    title="new.reactflow.dev/ts"
    href="https://new.reactflow.dev/ts"
    icon={
      <div className="rounded-full w-10 h-10 bg-blue-500 text-white font-black flex items-center justify-center">
        TS
      </div>
    }
  />
</Cards>

除了 React Flow，我们只需要引入一个依赖项 [`react-remark`](https://www.npmjs.com/package/react-remark) 来帮助我们在幻灯片中渲染 markdown。

```bash npm2yarn
npm install @xyflow/react react-remark
```

我们将修改生成的 `main.tsx` 文件，包含 React Flow 的样式，并用 `<ReactFlowProvider />` 包裹应用，确保能在组件内部访问 React Flow 实例；

```tsx filename="main.tsx" {3,7,12,20}
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

import App from './App';

import '@xyflow/react/dist/style.css';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ReactFlowProvider>
      {/* The parent element of the React Flow component needs a width and a height
          to work properly. If you're styling your app as you follow along, you
          can remove this div and apply styles to the #root element in your CSS.
       */}
      <div style={{ width: '100vw', height: '100vh' }}>
        <App />
      </div>
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

本教程将略过应用程序的样式设计部分，您可以使用任何熟悉的 CSS 框架或样式解决方案。如果您打算采用不同于直接编写 CSS 的方式（如 [Tailwind CSS](/examples/styling/tailwind)）来设计应用样式，可以跳过对 `index.css` 的导入。

<Callout>
  应用样式由您自行决定，但**必须始终**包含 React Flow 的样式文件！如果不需要默认样式，至少应引入 `@xyflow/react/dist/base.css` 中的基础样式。
</Callout>

我们将把演示文稿的每一页作为画布上的节点，因此需要创建一个新文件 `Slide.tsx` 作为渲染每张幻灯片的自定义节点组件。

```tsx filename="Slide.tsx"
import { type Node, type NodeProps } from '@xyflow/react';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideNode = Node<SlideData, 'slide'>;

export type SlideData = {};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideNode>) {
  return (
    <article className="slide nodrag" style={style}>
      <div>Hello, React Flow!</div>
    </article>
  );
}
```

这里我们将幻灯片宽度和高度设为常量（而非通过 CSS 设置节点样式），因为后续需要访问这些尺寸参数。同时我们还定义了 `SlideData` 类型存根，以便正确标注组件属性类型。

最后需要注册新的自定义节点并在屏幕上显示内容。

```tsx filename="App.tsx"
import { ReactFlow } from '@xyflow/react';
import { Slide } from './Slide.tsx';

const nodeTypes = {
  slide: Slide,
};

export default function App() {
  const nodes = [{ id: '0', type: 'slide', position: { x: 0, y: 0 }, data: {} }];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView />;
}
```

<Callout>
  关键提示：必须在组件**外部**定义 `nodeTypes` 对象（或使用 React 的 `useMemo` 钩子）！当 `nodeTypes` 对象变化时，整个流程图会重新渲染。
</Callout>

完成基础搭建后，可通过运行 `npm run dev` 启动开发服务器，您将看到如下效果：

<RemoteCodeViewer route="tutorials/presentation/scaffold" framework="react" />

目前还不太令人兴奋，但让我们先添加 Markdown 渲染功能并创建几个并排的幻灯片吧！

## 渲染 Markdown

我们希望简化幻灯片内容的添加过程，因此需要支持在幻灯片中使用 [Markdown](https://www.markdownguide.org/basic-syntax/) 编写内容。如果你还不熟悉，Markdown 是一种用于创建格式化文本文档的简单标记语言。如果你曾在 GitHub 上编写过 README 文件，那么你已经使用过 Markdown 了！

得益于之前安装的 `react-remark` 包，这一步变得非常简单。我们可以使用 `<Remark />` 组件将 Markdown 字符串内容渲染到幻灯片中。

```tsx filename="Slide.tsx" {2,9-11,21}
import { type Node, type NodeProps } from '@xyflow/react';
import { Remark } from 'react-remark';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideNode = Node<SlideData, 'slide'>;

export type SlideData = {
  source: string;
};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideNode>) {
  return (
    <article className="slide nodrag" style={style}>
      <Remark>{data.source}</Remark>
    </article>
  );
}
```

在 React Flow 中，节点可以存储渲染时使用的数据。这里我们通过给 `SlideData` 类型添加 `source` 属性来存储要显示的 Markdown 内容，并将其传递给 `<Remark />` 组件。我们可以用一些 Markdown 内容更新硬编码的节点来查看效果：

```tsx filename="App.tsx" {2, 10-27, 34}
import { ReactFlow } from '@xyflow/react';
import { Slide, SLIDE_WIDTH } from './Slide';

const nodeTypes = {
  slide: Slide,
};

export default function App() {
  const nodes = [
    {
      id: '0',
      type: 'slide',
      position: { x: 0, y: 0 },
      data: { source: '# Hello, React Flow!' },
    },
    {
      id: '1',
      type: 'slide',
      position: { x: SLIDE_WIDTH, y: 0 },
      data: { source: '...' },
    },
    {
      id: '2',
      type: 'slide',
      position: { x: SLIDE_WIDTH * 2, y: 0 },
      data: { source: '...' },
    },
  ];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView minZoom={0.1} />;
}
```

注意我们为 `<ReactFlow />` 组件添加了 `minZoom` 属性。由于我们的幻灯片尺寸较大，默认的最小缩放级别不足以缩小视图同时显示多张幻灯片。

<RemoteCodeViewer route="tutorials/presentation/rendering-markdown" framework="react" />

在上面的节点数组中，我们通过手动计算 `SLIDE_WIDTH` 常量值来确保幻灯片之间有足够的间距。下一节我们将设计一个算法来自动将节点排列成网格布局。

## 节点布局

我们经常被问及如何自动布局流程中的节点，在[布局指南](/learn/layouting/layouting)中，我们提供了关于如何使用dagre和d3-hierarchy等常见布局库的文档。这里你将编写自己的超简单布局算法，虽然会有点技术含量，但请跟紧我们！

对于演示应用，我们将构建一个简单的网格布局：从坐标0,0开始，每当有新的幻灯片添加到左侧、右侧、上方或下方时，就更新x或y坐标。

首先，需要更新`SlideData`类型，使其包含当前幻灯片左、右、上、下方幻灯片的可选ID。

```tsx filename="Slide.tsx" {3-6}
export type SlideData = {
  source: string;
  left?: string;
  up?: string;
  down?: string;
  right?: string;
};
```

直接在节点数据中存储这些信息能带来以下优势：

- 可以完全声明式地编写幻灯片，无需考虑节点和边的概念
- 通过遍历连接的幻灯片来计算演示文稿的布局
- 可为每张幻灯片添加导航按钮实现自动跳转（后续步骤会处理这点）

关键是一个名为`slidesToElements`的函数：它接收以ID索引的所有幻灯片对象和一个起始幻灯片ID，然后遍历每个连接的幻灯片，构建可传递给`<ReactFlow />`组件的节点和边数组。

算法流程大致如下：

- 将初始幻灯片的 ID 和位置 `{ x: 0, y: 0 }` 压入栈中
- 当栈不为空时循环执行以下操作：
  - 从栈中弹出当前位置和幻灯片 ID

  - 根据 ID 查找幻灯片数据
  - 将新节点推入节点数组，包含当前 ID、位置和幻灯片数据
  - 将该幻灯片 ID 加入已访问集合
  - 对于每个方向（左、右、上、下）...
    - 确保目标幻灯片未被访问过
    - 根据方向调整当前坐标：通过加减 `SLIDE_WIDTH` 或 `SLIDE_HEIGHT` 来更新 x 或 y 坐标
    - 将新位置和目标幻灯片 ID 压入栈中
    - 将连接当前幻灯片与目标幻灯片的新边推入边数组

    - 对其余方向重复上述操作...

如果一切顺利，我们就能将下方所示的幻灯片栈转换为排列整齐的网格！

<Image src="/img/tutorials/presentation/ideal-layout.png" wide />

来看具体实现。在名为 `slides.ts` 的文件中添加以下代码：

```tsx filename="slides.ts"
import { SlideData, SLIDE_WIDTH, SLIDE_HEIGHT } from './Slide';

export const slidesToElements = (initial: string, slides: Record<string, SlideData>) => {
  // Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.
  const stack = [{ id: initial, position: { x: 0, y: 0 } }];
  const visited = new Set();
  const nodes = [];
  const edges = [];

  // While that stack is not empty...
  while (stack.length) {
    // Pop the current position and slide id off the stack.
    const { id, position } = stack.pop();
    // Look up the slide data by id.
    const data = slides[id];
    const node = { id, type: 'slide', position, data };

    // Push a new node onto the nodes array with the current id, position, and slide
    // data.
    nodes.push(node);
    // add the slide's id to a set of visited slides.
    visited.add(id);

    // For every direction (left, right, up, down)...
    // Make sure the slide has not already been visited.
    if (data.left && !visited.has(data.left)) {
      // Take the current position and update the x or y coordinate by adding or
      // subtracting `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.
      const nextPosition = {
        x: position.x - SLIDE_WIDTH,
        y: position.y,
      };

      // Push the new position and the new slide's id onto a stack.
      stack.push({ id: data.left, position: nextPosition });
      // Push a new edge onto the edges array connecting the current slide to the
      // new slide.
      edges.push({ id: `${id}->${data.left}`, source: id, target: data.left });
    }

    // Repeat for the remaining directions...
  }

  return { nodes, edges };
};
```

为简洁起见，我们省略了右、上、下方向的代码，但每个方向的逻辑都是相同的。我们在注释中保留了相同的算法分解说明，以帮助理解代码结构。

下方是布局算法的演示应用，你可以编辑 `slides` 对象来观察不同方向的幻灯片添加如何影响布局。例如，尝试在 4 号幻灯片数据中添加 `down: '5'`，观察布局如何更新。

<RemoteCodeViewer route="tutorials/presentation/layout-demo" framework="react" />

如果您花些时间试用这个演示，可能会发现该算法的两个局限性：

1. 有可能构造出两个幻灯片重叠在同一位置的布局

2. 算法会忽略无法从初始幻灯片到达的节点

解决这些缺陷完全可行，但略微超出了本教程的范围。如果您尝试改进，请务必在 [discord 服务器](https://discord.com/invite/RVmnytFmGW) 上与我们分享您的解决方案！

编写完布局算法后，我们可以回到 `App.tsx`，移除硬编码的 nodes 数组，改用新的 `slidesToElements` 函数。

```tsx filename="App.tsx" {2,3,5-9,15-16,24}
import { ReactFlow } from '@xyflow/react';
import { slidesToElements } from './slides';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  '0': { source: '# Hello, React Flow!', right: '1' },
  '1': { source: '...', left: '0', right: '2' },
  '2': { source: '...', left: '1' },
};

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides);

export default function App() {
  return (
    <ReactFlow
      nodes={nodes}
      nodeTypes={nodeTypes}
      fitView
      fitViewOptions={{ nodes: [{ id: initialSlide }] }}
      minZoom={0.1}
    />
  );
}
```

由于流程图中的幻灯片是静态的，我们可以将 `slidesToElements` 调用移到组件 _外部_，确保组件重新渲染时不会重复计算布局。或者，您也可以使用 React 的 `useMemo` 钩子在组件内部定义，但仅计算一次。

由于我们现在有了"初始"幻灯片的概念，我们还使用了 `fitViewOptions` 来确保画布首次加载时聚焦于初始幻灯片。

## 幻灯片导航

目前我们的演示文稿已以网格形式布局，但需要手动平移画布才能查看每张幻灯片，这对演示来说并不实用！我们将添加三种不同的幻灯片导航方式：

- 点击节点聚焦功能，可通过点击节点跳转到不同幻灯片。

- 每张幻灯片上的导航按钮，支持按任意有效方向顺序切换幻灯片。

- 使用方向键进行键盘导航，无需鼠标操作或直接与幻灯片交互即可浏览演示内容。

### 点击聚焦

`<ReactFlow />` 元素可接收 [`onNodeClick`](/api-reference/react-flow#on-node-click) 回调函数，当点击任意节点时触发。除了鼠标事件本身，我们还能获取被点击节点的引用，结合 `fitView` 方法可实现画布平移定位。

[`fitView`](/api-reference/types/react-flow-instance#fit-view) 是 ReactFlow 实例的方法，通过 [`useReactFlow`](/api-reference/types/react-flow-instance#use-react-flow) 钩子可获取其访问权限。

```tsx filename="App.tsx" {1-2,17-23,29}
import { useCallback } from 'react';
import { ReactFlow, useReactFlow, type NodeMouseHandler } from '@xyflow/react';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  ...
}

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides);

export default function App() {
  const { fitView } = useReactFlow();
  const handleNodeClick = useCallback<NodeMouseHandler>(
    (_, node) => {
      fitView({ nodes: [node], duration: 150 });
    },
    [fitView],
  );

  return (
    <ReactFlow
      ...
      fitViewOptions={{ nodes: [{ id: initialSlide }] }}
      onNodeClick={handleNodeClick}
    />
  );
}
```

<Callout>
  务必记得将 `fitView` 包含在 `handleNodeClick` 回调的依赖数组中。这是因为 `fitView` 函数会在 ReactFlow 初始化视口后被替换。若遗漏此步骤，你会发现 `handleNodeClick` 完全失效（是的，我们自己有时也会忘记这步 <Emoji content="🫠" />）。
</Callout>

不带参数调用 `fitView` 会尝试将所有节点适配到视图中，但我们只想聚焦被点击的节点！[`FitViewOptions`](/api-reference/types/fit-view-options) 对象允许我们指定需要聚焦的节点数组：本例中就是被点击的那个节点。

<RemoteCodeViewer route="tutorials/presentation/focus-on-click" framework="react" />

### 幻灯片控制

点击聚焦节点的方式适合先缩略查看整体，再聚焦特定幻灯片，但对于演示文稿导航并不实用。这一步我们将为每张幻灯片添加控制按钮，实现在任意方向跳转至关联幻灯片。

我们给每张幻灯片添加 `<footer>`，根据连接情况有条件地渲染各方向按钮。同时预先创建 `moveToNextSlide` 回调函数供后续使用。

```tsx filename="Slide.tsx" {3,8,13-18}
import { type NodeProps, fitView } from '@xyflow/react';
import { Remark } from 'react-remark';
import { useCallback } from 'react';

...

export function Slide({ data }: NodeProps<SlideNide>) {
  const moveToNextSlide = useCallback((id: string) => {}, []);

  return (
    <article className="slide nodrag" style={style}>
      <Remark>{data.source}</Remark>
      <footer className="slide__controls nopan">
        {data.left && (<button onClick={() => moveToNextSlide(data.left)}>←</button>)}
        {data.up && (<button onClick={() => moveToNextSlide(data.up)}>↑</button>)}
        {data.down && (<button onClick={() => moveToNextSlide(data.down)}>↓</button>)}
        {data.right && (<button onClick={() => moveToNextSlide(data.right)}>→</button>)}
      </footer>
    </article>
  );
}
```

页脚样式可自由设计，但务必添加 `"nopan"` 类来防止操作按钮时画布发生平移。

要实现 `moveToSlide` 功能，我们将再次利用 `fitView`。之前我们通过点击节点的实际引用来传递给 `fitView`，但这次我们只有节点的 id。你可能会想通过 id 查找目标节点，但实际上这并非必要！查看 [`FitViewOptions`](/api-reference/types/fit-view-options) 的类型定义可以发现，我们传入的节点数组只需包含 `id` 属性即可：

```ts filename="https://reactflow.dev/api-reference/types/fit-view-options" {7}
export type FitViewOptions = {
  padding?: number;
  includeHiddenNodes?: boolean;
  minZoom?: number;
  maxZoom?: number;
  duration?: number;
  nodes?: (Partial<Node> & { id: Node['id'] })[];
};
```

`Partial<Node>` 表示 `Node` 对象类型的所有字段都被标记为可选，然后我们通过交叉类型 `{ id: Node['id'] }` 确保 `id` 字段始终必填。这意味着只需传入包含 `id` 属性的对象，`fitView` 就能正确处理！

```tsx filename="Slide.tsx" {1,4,6-9}
import { type NodeProps, useReactFlow } from '@xyflow/react';

export function Slide({ data }: NodeProps<SlideNide>) {
  const { fitView } = useReactFlow();

  const moveToNextSlide = useCallback(
    (id: string) => fitView({ nodes: [{ id }] }),
    [fitView],
  );

  return (
    <article className="slide" style={style}>
      ...
    </article>
  );
}
```

<RemoteCodeViewer route="tutorials/presentation/slide-controls" framework="react" />

### 键盘导航

最后的关键是为演示文稿添加键盘导航功能。总是需要点击幻灯片来切换并不方便，因此我们将添加一些键盘快捷键来简化操作。React Flow 允许我们通过 [`onKeyDown`](/api-reference/react-flow#on-key-down) 等处理器监听 `<ReactFlow />` 组件上的键盘事件。

到目前为止，当前聚焦的幻灯片是通过画布位置隐式确定的，但如果我们需要在整个画布上处理按键事件，就必须显式地追踪当前幻灯片状态。这是因为当方向键被按下时，我们需要明确知道应该导航到哪个幻灯片！

```tsx filename="App.tsx" {1,2,13-14,17,23}
import { useState, useCallback } from 'react';
import { ReactFlow, useReactFlow } from '@xyflow/react';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  ...
}

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides)

export default function App() {
  const [currentSlide, setCurrentSlide] = useState(initialSlide);
  const { fitView } = useReactFlow();

  const handleNodeClick = useCallback<NodeMouseHandler>(
    (_, node) => {
      fitView({ nodes: [node] });
      setCurrentSlide(node.id);
    },
    [fitView],
  );

  return (
    <ReactFlow
      ...
      onNodeClick={handleNodeClick}
    />
  );
}
```

我们为流程组件添加了状态变量 `currentSlide`，并确保在点击节点时及时更新它。接下来，我们将编写一个回调函数来处理画布上的键盘事件：

```tsx filename="App.tsx"
export default function App() {
  const [currentSlide, setCurrentSlide] = useState(initialSlide);
  const { fitView } = useReactFlow();

  ...

  const handleKeyPress = useCallback<KeyboardEventHandler>(
    (event) => {
      const slide = slides[currentSlide];

      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowRight':
          const direction = event.key.slice(5).toLowerCase();
          const target = slide[direction];

          if (target) {
            event.preventDefault();
            setCurrentSlide(target);
            fitView({ nodes: [{ id: target }] });
          }
      }
    },
    [currentSlide, fitView],
  );

  return (
    <ReactFlow
      ...
      onKeyPress={handleKeyPress}
    />
  );
}
```

为了减少代码量，我们从按键事件中提取方向信息——例如用户按下 `'ArrowLeft'` 时会得到 `'left'`。然后，如果该方向确实存在连接的幻灯片，我们就更新当前幻灯片并调用 `fitView` 进行导航！

我们还阻止了方向键的默认行为，避免窗口上下滚动。在本教程中这是必要的，因为画布只是页面的一部分；如果你的应用中画布占据整个视口，可能就不需要这个操作。

大功告成！让我们通过最终效果回顾一下所学内容。

<RemoteCodeViewer route="tutorials/presentation/app" framework="react" />

## 最终总结

即使你不打算开发下一个 [Prezi](https://prezi.com)，本教程仍然展示了 React Flow 的几个实用功能：

- 使用 [`useReactFlow`](/api-reference/hooks/use-react-flow) 钩子来访问 `fitView` 方法

- 通过 [`onNodeClick`](/api-reference/react-flow#on-node-click) 事件处理器监听流程图中所有节点的点击事件

- 通过 [`onKeyPress`](/api-reference/react-flow#on-key-press) 事件处理器监听整个画布的键盘事件

我们还探讨了如何自行实现一个简单的布局算法。布局问题是我们经常被问到的主题，但如果需求不太复杂，完全可以自己动手实现解决方案！

如果你想扩展这个项目，可以尝试解决我们提到的布局算法问题，设计一个支持多种布局的更复杂的 `Slide` 组件，或者完全不同的功能。

你可以使用完整的[源代码](https://github.com/xyflow/react-flow-slide-show)作为起点，也可以基于今天的成果继续开发。我们非常期待看到你的作品，欢迎在[Discord服务器](https://discord.com/invite/RVmnytFmGW)或[Twitter](https://twitter.com/reactflowdev)上与我们分享。