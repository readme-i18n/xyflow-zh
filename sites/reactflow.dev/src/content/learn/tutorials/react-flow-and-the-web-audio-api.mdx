---

sidebarTitle: Web Audio API
title: 集成 React Flow 与 Web Audio API
intro: "今天我们将探讨如何利用 React Flow 和 Web Audio API 创建一个交互式音频实验场。我们将从零开始，先了解 Web Audio API，再研究如何处理 React Flow 中的常见场景：状态管理、实现自定义节点以及增加交互性。"
date: 2023/04/14
authors: ['hayleigh']
tags: ['react-flow', 'web-audio-api', 'how-to']
image: /img/tutorials/webaudio/web-audio-blog-thumb.png
---

import { Emoji } from '@xyflow/xy-ui';
import { Callout, Tabs } from 'nextra/components';
import { Embed, Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

今天我们将探讨如何利用 React Flow 和 Web Audio API 创建一个交互式音频实验场。我们将从零开始，先了解 Web Audio API，再研究如何处理 React Flow 中的常见场景：状态管理、实现自定义节点以及增加交互性。

<Image
  src="/img/tutorials/webaudio/bleep-cafe.png"
  alt="A screenshot of bleep.cafe, a visual audio programming environment. In it,
    there are four nodes connected together: an xy pad, an oscillator node, a
    volume node, and a master output."
  wide
  caption="This is bleep.cafe. We're going to learn everything we need to know to
    build something just like it!"
/>

早些时候，我在 React Flow 的 [discord 服务器](https://discord.com/invite/RVmnytFmGW) 分享了一个正在开发的项目。它叫 [bleep.cafe](https://bleep.cafe)，是一个完全在浏览器中学习数字合成的轻量级网页应用。许多人对这类项目的构建方式很感兴趣：大多数人甚至不知道**浏览器内置了完整的合成器引擎！**

本教程将带领我们逐步构建一个类似的功能。虽然可能会跳过某些细节，但如果你是 React Flow 或 Web Audio API 的新手，基本上都能跟随教程并在最后完成一个可运行的项目。

如果你已经是 React Flow 高手，可以先阅读关于 Web Audio API 的第一部分，然后直接跳到第三节了解如何将它们整合起来！

不过首先...

## 演示示例！

<Embed src="https://xyflow.github.io/react-flow-web-audio/" />

<Callout type="warning">
  本教程中的示例会发出声音。为避免创作出前卫艺术作品，请记得在每个示例结束后将其静音！
</Callout>

## Web Audio API

在深入 React Flow 和交互式节点编辑器之前，我们需要快速了解 [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)。以下是需要掌握的重点：

- Web Audio API 提供了多种不同的音频节点，包括：
  - 音源节点（如 [OscillatorNode](https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode)、
    [MediaElementAudioSourceNode](https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode)）
  - 效果节点（如 [GainNode](https://developer.mozilla.org/en-US/docs/Web/API/GainNode)、
    [DelayNode](https://developer.mozilla.org/en-US/docs/Web/API/DelayNode)、
    [ConvolverNode](https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode)）
  - 输出节点（如 [AudioDestinationNode](https://developer.mozilla.org/en-US/docs/Web/API/AudioDestinationNode)）
- 音频节点可以相互连接形成（可能是环状的）处理图，通常称为音频处理图、信号图或信号链
- 音频处理由原生代码在独立线程中执行，这意味着即使主UI线程繁忙或被阻塞，仍可持续生成声音
- [AudioContext](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext) 作为音频处理图的核心控制器，可用于创建新音频节点以及全局暂停/恢复音频处理

### 声音初探

让我们通过实践来构建第一个 Web Audio 应用！这次不会做太复杂的功能：我们将制作一个简易的鼠标控制[特雷门琴](http://www.thereminworld.com/Article/14232/what-s-a-theremin-)。接下来的示例会使用 React（毕竟我们叫 React Flow 嘛！）以及 [`vite`](https://vitejs.dev) 来处理打包和热更新。

如果你偏好其他打包工具如 parcel 或 Create React App 也没问题，它们功能大同小异。你也可以选择 TypeScript 替代 JavaScript。为保持简洁今天暂不使用，但 React Flow 完全支持类型（且完全用 TypeScript 编写），使用起来非常顺畅！

```bash npm2yarn
npm create vite@latest -- --template react
```

Vite 会为我们搭建基础 React 应用结构，但我们可以直接删除默认资源并进入 `App.jsx` 开发。移除自动生成的演示组件后，首先创建 AudioContext 并组装所需节点：需要一个 OscillatorNode 来生成音调，以及一个 GainNode 来控制音量。

```js filename="./src/App.jsx"
// Create the brain of our audio-processing graph
const context = new AudioContext();

// Create an oscillator node to generate tones
const osc = context.createOscillator();

// Create a gain node to control the volume
const amp = context.createGain();

// Pass the oscillator's output through the gain node and to our speakers
osc.connect(amp);
amp.connect(context.destination);

// Start generating those tones!
osc.start();
```

<Callout type="info">
振荡器节点需要手动启动。

别忘了调用 `osc.start`，否则振荡器不会开始发声！

</Callout>

本应用中，我们将追踪鼠标在屏幕上的位置，并用它来设置振荡器节点的音高和增益节点的音量。

```jsx filename="./src/App.jsx" {12-27}
import React from 'react';

const context = new AudioContext();
const osc = context.createOscillator();
const amp = context.createGain();

osc.connect(amp);
amp.connect(context.destination);

osc.start();

const updateValues = (e) => {
  const freq = (e.clientX / window.innerWidth) * 1000;
  const gain = e.clientY / window.innerHeight;

  osc.frequency.value = freq;
  amp.gain.value = gain;
};

export default function App() {
  return <div style={{ width: '100vw', height: '100vh' }} onMouseMove={updateValues} />;
}
```

<Callout type="info">
`osc.frequency.value`, `amp.gain.value`...

Web Audio API 对普通对象属性和音频节点_参数_进行了明确区分。这种区分通过 `AudioParam` 类型体现。你可以在 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam) 中详细了解，目前只需知道：设置 `AudioParam` 的值必须使用 `.value` 属性，而不能直接赋值。

</Callout>

如果直接运行这个示例，可能会发现没有任何反应。AudioContext 通常会以暂停状态启动，这是为了防止广告劫持我们的扬声器。我们只需在 `<div />` 上添加点击事件处理器，当上下文处于暂停状态时恢复它即可轻松解决。

```jsx filename="./src/App.jsx" {1-7,12}
const toggleAudio = () => {
  if (context.state === 'suspended') {
    context.resume();
  } else {
    context.suspend();
  }
};

export default function App() {
  return (
    <div ...
      onClick={toggleAudio}
    />
  );
};
```

以上就是使用 Web Audio API 制作声音所需的全部基础！以下是完整代码示例，方便你对照查看：

<RemoteCodeViewer
  route="tutorials/webaudio/mouse-theremin"
  framework="react"
  
/>

现在让我们暂时搁置这些知识，来看看如何从零开始构建一个 React Flow 项目。

<Callout type="info">
  已经是 React Flow 专家？如果你已熟悉 React Flow，可以跳过下一节直接前往 [制作声音](#do-sound-to-it)。其他用户请跟随我们了解如何从头搭建 React Flow 项目。
</Callout>

## 搭建 React Flow 项目脚手架

稍后我们将结合所学的 Web Audio API、振荡器和增益节点知识，使用 React Flow 交互式构建音频处理图。不过现在，我们需要先搭建一个空的 React Flow 应用框架。

我们已经通过 Vite 搭建好了 React 应用，因此继续沿用该配置。如果你跳过了上一节内容，我们是通过执行 `npm create vite@latest -- --template react` 命令初始化的。当然你也可以选择任意喜欢的打包工具或开发服务器，这里的内容并不依赖 Vite。

本项目仅需添加三个额外依赖：用于 UI 的 `@xyflow/react`（核心依赖）、轻量级状态管理库 `zustand`（React Flow 底层使用）以及 ID 生成工具 `nanoid`。

```bash npm2yarn
npm install @xyflow/react zustand nanoid
```

我们将清空之前 Web Audio 速成课的所有内容，从头开始。首先按以下方式修改 `main.jsx`：

```jsx filename="./src/main.jsx"
import App from './App';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

// 👇 Don't forget to import the styles!
import '@xyflow/react/dist/style.css';
import './index.css';

const root = document.querySelector('#root');

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    {/* React flow needs to be inside an element with a known height and width to work */}
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlowProvider>
        <App />
      </ReactFlowProvider>
    </div>
  </React.StrictMode>,
);
```

这里有三个关键注意事项：

1. 必须**导入 React Flow 的 CSS 样式文件**以确保功能正常
2. React Flow 渲染器需要置于已知宽高的容器元素内，因此我们将外层 `<div />` 设为全屏尺寸
3. 要使用 React Flow 提供的某些钩子，组件必须包裹在 `<ReactFlowProvider />` 内或直接置于 `<ReactFlow />` 组件中，因此我们采用 Provider 包裹整个应用以确保兼容性

接下来，打开 `App.jsx` 创建一个空白的流程图：

```jsx filename="./src/App.jsx"
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';

export default function App() {
  return (
    <ReactFlow>
      <Background />
    </ReactFlow>
  );
}
```

我们会逐步扩展和完善这个组件。目前，我们添加了 React Flow 的内置组件 [`<Background />`](/api-reference/components/background) 来验证配置是否正确。现在运行 `npm run dev`（如果你没有选择 vite，请使用对应的命令启动开发服务器），然后在浏览器中查看。你应该能看到一个空白的流程图：

<Image
  src="/img/tutorials/webaudio/empty-flow.png"
  alt="Screenshot of an empty React Flow graph"
/>

保持开发服务器运行。我们可以在添加新功能时随时查看进度。

### 1. 使用 Zustand 进行状态管理

Zustand 存储将管理我们应用的所有 UI 状态。具体来说，它将保存 React Flow 图的节点和边、一些其他状态，以及用于更新这些状态的若干 _操作_。

要实现一个基本的交互式 React Flow 图，我们需要三个操作：

1. `onNodesChange` 用于处理节点的移动或删除。
2. `onEdgesChange` 用于处理 _边_ 的移动或删除。
3. `addEdge` 用于连接图中的两个节点。

现在创建一个新文件 `store.js`，并添加以下内容：

```js filename="./src/store.js"
import { applyNodeChanges, applyEdgeChanges } from '@xyflow/react';
import { nanoid } from 'nanoid';
import { createWithEqualityFn } from 'zustand/traditional';

export const useStore = createWithEqualityFn((set, get) => ({
  nodes: [],
  edges: [],

  onNodesChange(changes) {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },

  onEdgesChange(changes) {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },

  addEdge(data) {
    const id = nanoid(6);
    const edge = { id, ...data };

    set({ edges: [edge, ...get().edges] });
  },
}));
```

Zustand 的使用极其简单。我们创建一个接收 `set` 和 `get` 函数的函数，返回包含初始状态和更新操作的对象。通过 `set` 函数进行不可变更新，`get` 函数则用于读取当前状态——这就是 zustand 的全部核心逻辑。

`onNodesChange` 和 `onEdgesChange` 中的 `changes` 参数表示节点或边被移动/删除等事件。React Flow 提供了[辅助函数](/api-reference/utils/apply-node-changes)[工具](/api-reference/utils/apply-edge-changes)来自动处理这些变更，我们只需用新节点数组更新存储即可。

当两个节点建立连接时，`addEdge` 将被调用。其 `data` 参数_几乎_就是有效的边数据，仅缺少 id 字段。这里我们使用 nanoid 生成 6 位随机 ID 并将边添加到图中，过程非常直观。

回到 `<App />` 组件，我们可以将 React Flow 与这些操作挂钩，实现完整功能。

```jsx filename="./src/App.jsx" {3,5,7-13,16,20-24}
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

关于 `selector` 的作用：Zustand 允许通过选择器函数从存储中精确提取所需状态片段。结合 `shallow` 相等性判断函数，这意味着当不关心的状态变化时通常不会触发重新渲染。

目前，我们的存储规模较小，实际上需要从中获取所有内容来渲染 React Flow 图形。但随着规模扩大，这个选择器将确保我们不会频繁地重新渲染_所有_内容。

这就是实现交互式图形所需的全部功能：我们可以移动节点、连接节点以及删除节点。为了演示，_临时_在存储中添加一些虚拟节点：

```js filename="./store.jsx" {2-6}
const useStore = createWithEqualityFn((set, get) => ({
  nodes: [
    { id: 'a', data: { label: 'oscillator' }, position: { x: 0, y: 0 } },
    { id: 'b', data: { label: 'gain' }, position: { x: 50, y: 50 } },
    { id: 'c', data: { label: 'output' }, position: { x: -50, y: 100 } }
  ],
  ...
}));
```

<RemoteCodeViewer route="tutorials/webaudio/state-management" framework="react" />

### 2. 自定义节点

很好，我们现在有了一个可以开始操作的交互式 React Flow 实例。虽然添加了一些虚拟节点，但它们目前只是默认的无样式节点。在这一步中，我们将添加三个带有交互控件的自定义节点：

1. 一个振荡器节点，包含音高和波形类型的控件。
2. 一个增益节点，包含音量控制。
3. 一个输出节点，包含一个开关音频处理的按钮。

让我们创建一个新文件夹 `nodes/`，并为每个要创建的自定义节点新建一个文件。从振荡器开始，我们需要两个控件和一个源句柄，用于将振荡器的输出连接到其他节点。

```jsx filename="./src/nodes/Osc.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';

import { useStore } from '../store';

export default function Osc({ id, data }) {
  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency} />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform</span>
          <select className="nodrag" value={data.type}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
};
```

<Callout type="info">
"nodrag" 非常重要。

请注意 `"nodrag"` 类被同时添加到 `<input />` 和 `<select />` 元素上。_极其重要_的是必须记住添加这个类，否则 React Flow 会拦截鼠标事件，导致你只能不停地拖动节点！

</Callout>

如果我们尝试渲染这个自定义节点，会发现输入框没有任何反应。
这是因为输入值被 `data.frequency` 和 `data.type` 固定了，而我们既没有监听变化的事件处理器，也没有更新节点数据的机制！

要解决这个问题，我们需要回到 store 并添加一个 `updateNode` 动作：

```js filename="./src/store.js"
export const useStore = createWithEqualityFn((set, get) => ({
  ...

  updateNode(id, data) {
    set({
      nodes: get().nodes.map(node =>
        node.id === id
          ? { ...node, data: { ...node.data, ...data } }
          : node
      )
    });
  },

  ...
}));
```

这个动作将处理部分数据更新，例如如果我们只想更新节点的 `frequency`，只需调用 `updateNode(id, { frequency: 220 }`。
现在只需将这个动作引入 `<Osc />` 组件，并在输入变化时调用它。

```jsx filename="./src/nodes/Osc.jsx" {3,7-10,13,28,35}
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from '../store';

const selector = (id) => (store) => ({
  setFrequency: (e) => store.updateNode(id, { frequency: +e.target.value }),
  setType: (e) => store.updateNode(id, { type: e.target.value }),
});

export default function Osc({ id, data }) {
  const { setFrequency, setType } = useStore(selector(id), shallow);

  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency:</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency}
            onChange={setFrequency}
          />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform:</span>
          <select className="nodrag" value={data.type} onChange={setType}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
        </label>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
}
```

看，那个 `selector` 又出现了！注意这次我们用它从通用的 `updateNode` 动作派生出两个事件处理器：`setFrequency` 和 `setType`。

最后的关键是告诉 React Flow 如何渲染我们的自定义节点。为此需要创建一个 `nodeTypes` 对象：其键名对应节点的 `type` 属性，值则是要渲染的 React 组件。

```jsx filename="./src/App.jsx" {5,16-18,26}
import React from 'react';
import { ReactFlow } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';
import Osc from './nodes/Osc';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

const nodeTypes = {
  osc: Osc,
};

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      nodeTypes={nodeTypes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

<Callout type="info">
避免不必要的渲染。

重要提示：应在 `<App />` 组件外部定义 `nodeTypes`（或使用 React 的 [`useMemo`](https://react.dev/reference/react/useMemo)），以避免每次渲染都重新计算。

</Callout>

如果开发服务器正在运行，看到界面尚未变化时请不要惊慌！
因为我们尚未为临时节点指定正确的类型，React Flow 会默认回退到基础节点渲染。只要将任意节点类型改为 `osc` 并设置 `frequency` 和 `type` 的初始值，就能看到自定义节点正常渲染了。

```js title"./src/store.js"
const useStore = createWithEqualityFn((set, get) => ({
  nodes: [
    { type: 'osc',
      id: 'a',
      data: { frequency: 220, type: 'square' },
      position: { x: 0, y: 0 }
    },
    ...
  ],
  ...
}));
```

<RemoteCodeViewer
    route="tutorials/webaudio/custom-node"
    framework="react"
    
  />

<Callout type="info">
遇到样式问题？

如果按照本文逐步实现代码，你会发现自定义节点与上方预览效果不同。为保持内容简洁，我们省略了代码片段中的样式部分。

要了解如何设计自定义节点样式，请查阅[主题定制文档](/learn/customization/theming)或参考[使用Tailwind的示例](/examples/styling/tailwind)。

</Callout>

实现增益节点的过程几乎相同，这部分将留作练习。现在我们把注意力转向输出节点——这个节点不需要参数控件，但需要实现信号处理的开关切换。由于尚未编写音频相关代码，目前我们暂时在状态库中添加一个标志位和对应的切换动作。

```js filename="./src/store.js"
const useStore = createWithEqualityFn((set, get) => ({
  ...

  isRunning: false,

  toggleAudio() {
    set({ isRunning: !get().isRunning });
  },

  ...
}));
```

自定义节点本身的实现非常简单：

```jsx filename="./src/nodes/Out.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';
import { useStore } from '../store';

const selector = (store) => ({
  isRunning: store.isRunning,
  toggleAudio: store.toggleAudio,
});

export default function Out({ id, data }) {
  const { isRunning, toggleAudio } = useStore(selector, shallow);

  return (
    <div>
      <Handle type="target" position="top" />

      <div>
        <p>Output Node</p>

        <button onClick={toggleAudio}>
          {isRunning ? (
            <span role="img" aria-label="mute">
              🔇
            </span>
          ) : (
            <span role="img" aria-label="unmute">
              🔈
            </span>
          )}
        </button>
      </div>
    </div>
  );
}
```

现在整体已经初具雏形！

<RemoteCodeViewer
  route="tutorials/webaudio/custom-nodes"
  framework="react"
  
/>

接下来需要...

## 实现音频处理

我们已经实现了一个交互式图表，并且能够更新节点数据，现在让我们加入关于 Web Audio API 的知识。首先创建一个新文件 `audio.js`，并初始化一个新的音频上下文和一个空的 `Map`。

```js filename="./src/audio.js"
const context = new AudioContext();
const nodes = new Map();
```

我们将通过挂钩到存储中的不同操作来管理音频图。例如当调用 `addEdge` 操作时连接两个音频节点，或在调用 `updateNode` 时更新音频节点的属性，以此类推。

<Callout type="warning">
硬编码节点

本文前面部分我们在存储中硬编码了几个节点，但音频图对这些节点一无所知！在最终项目中我们可以去除所有这些硬编码部分，但目前**非常关键**的是我们也需要硬编码一些音频节点。

具体实现如下：

```js filename="./src/audio.js" {4-7,9-10,12,14-16}
const context = new AudioContext();
const nodes = new Map();

const osc = context.createOscillator();
osc.frequency.value = 220;
osc.type = 'square';
osc.start();

const amp = context.createGain();
amp.gain.value = 0.5;

const out = context.destination;

nodes.set('a', osc);
nodes.set('b', amp);
nodes.set('c', out);
```

</Callout>

### 1. 节点变更

当前图表中可能发生两类需要响应的节点变更：更新节点的 `data` 属性，以及从图表中移除节点。我们已经为前者准备了操作，让我们先处理这个场景。

在 `audio.js` 文件中，我们将定义一个名为 `updateAudioNode` 的函数，该函数通过传入节点 ID 和部分 `data` 对象来更新 `Map` 中现有的节点：

```js filename="./src/audio.js"
export function updateAudioNode(id, data) {
  const node = nodes.get(id);

  for (const [key, val] of Object.entries(data)) {
    if (node[key] instanceof AudioParam) {
      node[key].value = val;
    } else {
      node[key] = val;
    }
  }
}
```

<Callout type="info">
  请注意音频节点上的属性可能是特殊的 `AudioParam` 类型，必须采用与常规对象属性不同的更新方式。
</Callout>

接下来我们需要更新 store 中的 `updateNode` 操作，使其在更新过程中调用这个函数：

```js filename="./src/store.js"
import { updateAudioNode } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  updateNode(id, data) {
    updateAudioNode(id, data);
    set({ nodes: ... });
  },

  ...
}));

```

我们需要处理的另一个变更是从图中移除节点。如果在图中选中节点并按退格键，React Flow 会将其移除。虽然我们已连接的 `onNodesChange` 操作会隐式处理这一行为，但现在我们需要额外处理逻辑，因此需要为 React Flow 的 `onNodesDelete` 事件配置新操作。

这个实现其实相当简单，为节省阅读时间，我将直接展示接下来的三段代码而不作说明。

<Tabs items={['./src/audio.js', './src/store.js', './src/App.jsx']}>
  <Tabs.Tab>

```js
export function removeAudioNode(id) {
  const node = nodes.get(id);

  node.disconnect();
  node.stop?.();

  nodes.delete(id);
}
```

  </Tabs.Tab>
  <Tabs.Tab>

```js
import { ..., removeAudioNode } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  removeNodes(nodes) {
    for (const { id } of nodes) {
      removeAudioNode(id)
    }
  },

  ...
}));
```

  </Tabs.Tab>
  <Tabs.Tab>

```jsx
const selector = store => ({
  ...,
  onNodesDelete: store.removeNodes
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      onNodesDelete={store.onNodesDelete}
      ...
    >
      <Background />
    </ReactFlow>
  )
};
```

  </Tabs.Tab>
</Tabs>

唯一需要注意的是：`onNodesDelete` 会以_数组_形式向回调函数传递被删除的节点，因为可能同时删除多个节点！

### 2. 边变更处理

我们离实际发出声音已经非常接近了！最后只需处理图中边的变更。与节点变更类似，我们已经具备创建新边的操作，同时 `onEdgesChange` 也会隐式处理被移除的边。

要处理新连接，我们只需要从`addEdge`操作创建的边中获取`source`和`target`的id。然后就可以在`Map`中查找这两个节点并将它们连接起来。

<Tabs items={["./src/audio.js", "./src/store.js"]}>
  <Tabs.Tab>

```js
export function connect(sourceId, targetId) {
  const source = nodes.get(sourceId);
  const target = nodes.get(targetId);

  source.connect(target);
}
```

  </Tabs.Tab>
  <Tabs.Tab>

```js
import { ..., connect } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  addEdge(data) {
    ...

    connect(data.source, data.target);
  },

  ...
}));
```

  </Tabs.Tab>
</Tabs>

我们已经看到React Flow接受`onNodesDelete`处理程序，不出所料，它也有一个`onEdgesDelete`处理程序！实现`disconnect`并将其连接到我们的存储和React Flow实例的方法与之前基本相同，所以我们也将这部分留给你来完成！

### 3. 开启扬声器

你可能还记得，我们的`AudioContext`可能一开始处于暂停状态，以防止可能令人讨厌的自动播放问题。我们已经在存储中为`<Out />`组件模拟了所需的数据和操作，现在只需要用真实上下文的状态和恢复/暂停方法来替换它们。

```js filename="./src/audio.js"
export function isRunning() {
  return context.state === 'running';
}

export function toggleAudio() {
  return isRunning() ? context.suspend() : context.resume();
}
```

虽然到目前为止我们的音频函数还没有返回任何内容，但我们需要从`toggleAudio`返回，因为这些方法是异步的，我们不希望过早地更新存储！

```js filename="./src/store.js"
import { ..., isRunning, toggleAudio } from './audio'

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  isRunning: isRunning(),

  toggleAudio() {
    toggleAudio().then(() => {
      set({ isRunning: isRunning() });
    });
  }
}));
```

瞧，我们做到了！我们现在已经整合了足够的内容来真正_发出声音_！让我们看看实际效果如何。

<RemoteCodeViewer
  route="tutorials/webaudio/hardcoded-audio"
  framework="react"
  
/>

### 4. 创建新节点

到目前为止，我们一直在处理图中硬编码的节点集合。这对于原型设计来说已经足够，但要让其真正实用，我们需要一种动态添加新节点的方法。最终任务就是实现这一功能：我们将从音频代码开始逆向操作，最终创建一个基础工具栏。

实现`createAudioNode`函数非常简单。我们只需要新节点的ID、要创建的节点类型及其初始数据：

```js filename="./src/audio.js"
export function createAudioNode(id, type, data) {
  switch (type) {
    case 'osc': {
      const node = context.createOscillator();
      node.frequency.value = data.frequency;
      node.type = data.type;
      node.start();

      nodes.set(id, node);
      break;
    }

    case 'amp': {
      const node = context.createGain();
      node.gain.value = data.gain;

      nodes.set(id, node);
      break;
    }
  }
}
```

接下来需要在store中创建`createNode`函数。节点ID将由nanoid生成，我们会为每种节点类型硬编码一些初始数据，因此唯一需要传入的参数就是要创建的节点类型：

```js filename="./src/store.js"
import { ..., createAudioNode } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  createNode(type) {
    const id = nanoid();

    switch(type) {
      case 'osc': {
        const data = { frequency: 440, type: 'sine' };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }

      case 'amp': {
        const data = { gain: 0.5 };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }
    }
  }
}));
```

本可以更智能地计算新节点的位置，但为了保持简单，我们暂时将其硬编码为`{ x: 0, y: 0 }`。

最后的关键是创建一个能触发`createNode`操作的工具栏组件。为此我们将回到`App.jsx`，使用内置的[`<Panel />`](/docs//api-reference/components/panel/)组件。

```jsx filename="./src/App.jsx"
...
import { ReactFlow,  Panel } from '@xyflow/react';
...

const selector = (store) => ({
  ...,
  createNode: store.createNode,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow>
      <Panel position="top-right">
        ...
      </Panel>
      <Background />
    </ReactFlow>
  );
};
```

这里不需要复杂功能，只需几个按钮来触发带有相应节点类型的`createNode`操作：

```jsx filename="./src/App.jsx"
<Panel position="top-right">
  <button onClick={() => store.createNode('osc')}>osc</button>
  <button onClick={() => store.createNode('amp')}>amp</button>
</Panel>
```

至此...大功告成！我们现在拥有一个功能完整的音频图编辑器，能够：

- 创建新的音频节点
- 通过UI控件更新节点数据  
- 连接节点  
- 删除节点和连接  
- 启动/停止音频处理

这是开头的演示，但这次你可以查看源代码以确保没有遗漏任何内容。

<RemoteCodeViewer route="tutorials/webaudio/demo" framework="react" />

## 最终思考

呼——这篇内容很长，但我们完成了！通过努力，我们收获了一个有趣的交互式音频实验场，过程中学习了Web Audio API的相关知识，也对"运行"React Flow图表的实现方式有了更深理解。

如果你看到这里并在想："Hayleigh，我根本不会开发Web Audio应用，这些内容有用吗？"那么你很幸运——确实有用！你可以将我们连接Web Audio API的方法应用到其他基于图的计算引擎（如[behave-graph](https://github.com/bhouston/behave-graph)）。事实上，有人已经这么做了并创建了[behave-flow](https://github.com/beeglebug/behave-flow)！

这个项目还有很多扩展方向。如果你想继续完善，这里有些建议：

- 添加更多节点类型  
- 允许节点连接到其他节点的`AudioParams`  
- 使用[`AnalyserNode`](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode)可视化节点或信号输出  
- 任何你能想到的功能！

如果你正在寻找灵感，市面上有不少项目采用了基于节点的用户界面来处理音频相关功能。我个人最喜欢的几个包括 [Max/MSP](https://cycling74.com/products/max/)、[Reaktor](https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/) 和 [Pure Data](https://puredata.info/)。其中 Max 和 Reaktor 是闭源的商业软件，但你依然可以从中借鉴一些创意思路 <Emoji content="🕵️" />。

你可以将完整的[源代码](https://github.com/xyflow/react-flow-web-audio)作为起点，也可以基于我们今天构建的内容继续开发。我们非常期待看到你的创作成果，欢迎通过 [Discord 服务器](https://discord.com/invite/RVmnytFmGW) 或 [Twitter](https://twitter.com/xyflowdev) 与我们分享。

React Flow 是一家由用户资助的独立公司。如果你想支持我们，可以选择 [在 Github 赞助](https://github.com/sponsors/xyflow) 或 [订阅我们的 Pro 方案](/pro/)。