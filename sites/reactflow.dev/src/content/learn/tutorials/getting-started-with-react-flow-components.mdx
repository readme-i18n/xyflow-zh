---

sidebarTitle: React Flow UI
title: React Flow UI 入门指南
intro: words
date: 2024/01/20
authors: ['hayleigh']
tags: ['react-flow', 'ui', 'shadcn', 'computational']
image: ''
---

import { Emoji } from '@xyflow/xy-ui';
import { Callout } from 'nextra/components';
import { Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

_**2025年7月更新**："React Flow UI" 前身为 "React Flow Components"。我们进行更名是因为现在它既包含组件也包含模板。此外，由于它基于 shadcn/ui 构建，"UI" 的命名能让开发者更容易识别其关联性并理解我们提供的功能。_

最近，我们开源项目阵容中新增了一个令人兴奋的成员：React Flow Components。这些是预构建的节点、边和其他 UI 元素，您可以快速添加到 React Flow 应用程序中立即使用。关键在于这些组件构建于 [shadcn/ui](https://ui.shadcn.com) 和 shadcn CLI 之上。

我们此前在 [xyflow 博客](https://xyflow.com/blog/react-flow-components) 上分享过相关经验以及选择 shadcn 的原因，但本教程将重点介绍如何从零开始使用 shadcn、Tailwind CSS 和 React Flow Components。

<Callout>
**等等，什么是 shadcn？**

不对，应该说**谁**是 shadcn！Shadcn 是一位开发者，他创作了一系列预设计组件集合 `shadcn/ui`。注意到我们刚才没有用_库_这个词吗？Shadcn 采用了一种独特的方式：组件会被添加到你的项目源代码中并由你"拥有"——一旦添加组件，你就可以自由修改它们以满足需求！

</Callout>

## 快速开始

首先，我们将新建一个 [`vite`](https://vitejs.dev) 项目，并配置所有必需的依赖项。从运行以下命令开始：

```bash copy npm2yarn
npx create-vite@latest
```

Vite 能为多种流行框架搭建项目脚手架，但我们只需要 React！另外请确保创建的是 **TypeScript** 项目。React Flow 的文档混合使用了 JavaScript 和 TypeScript，但对于 shadcn 组件来说 TypeScript 是_必需_的！

所有 shadcn 和 React Flow 组件都使用 [Tailwind CSS](https://tailwindcss.com/docs/utility-first) 进行样式设计，因此接下来我们需要安装它和其他几个依赖：

```bash copy npm2yarn
npm install -D tailwindcss postcss autoprefixer
```

Tailwind 是一个高度可定制的实用优先 CSS 框架，大部分定制工作都在 `tailwind.config.js` 文件中完成。幸运的是，这个包能为我们生成默认配置：

```bash copy npm2yarn
npx tailwindcss init -p
```

Tailwind 的工作原理是扫描项目源代码并构建仅包含你所用工具的 CSS 文件。为确保这个过程顺利进行，我们需要修改两处配置：

1. 更新 `tailwind.config.js` 中的 `content` 字段，使其包含可能含有 Tailwind 类的所有源文件。

```js filename="tailwind.config.js" {3}
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{ts,tsx,js,jsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

2. 将生成的 `src/index.css` 文件替换为 Tailwind 指令：

```css filename="src/index.css"
@tailwind base;
@tailwind components;
@tailwind utilities;
```

最后，我们可以删除生成的 `src/App.css` 文件，并将 `src/App.jsx` 修改为仅渲染一个空的 `div`：

```jsx filename="src/App.jsx"
function App() {
  return <div className="w-screen h-screen p-8"></div>;
}

export default App;
```

<Callout>
  `w-screen` 和 `h-screen` 类是 Tailwind 工具类的两个示例。如果你习惯使用其他方式为 React 应用添加样式，一开始可能会觉得这种方式有些奇怪。你可以将 Tailwind 类视为增强版的内联样式：它们受限于一套设计系统，并且你可以使用响应式媒体查询或诸如 `hover` 和 `focus` 这样的伪类。
</Callout>

### 配置 shadcn/ui

Vite 在生成 TypeScript 项目时会为我们搭建一些 `tsconfig` 文件，我们需要对这些文件进行一些修改，以便 shadcn 组件能够正常工作。shadcn CLI 相当智能（稍后会详细介绍），但它无法适应所有项目结构，因此相互依赖的 shadcn 组件会利用 TypeScript 的导入路径功能。

在 `tsconfig.json` 和 `tsconfig.app.json` 中，向 `compilerOptions` 对象添加以下内容：

```json filename="tsconfig.json" {3-8}
{
  ...
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

然后我们需要让 Vite 学会如何解析这些路径：

```bash copy npm2yarn
npm i -D @types/node
```

```js filename="vite.config.js" {3, 7-11}
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'node:path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

现在，不妨给自己一点鼓励，休息片刻喝杯茶。虽然前期需要完成大量配置工作，但一旦设置好 shadcn CLI，我们就能通过单一命令为项目添加新组件——即使这些组件存在依赖关系或需要修改现有文件！

现在可以运行以下命令在项目中设置 shadcn/ui：

```bash copy npm2yarn
npx shadcn@latest init
```

CLI 会询问几个关于项目的问题，随后将在项目根目录生成 `components.json` 文件，并通过主题扩展更新 `tailwind.config.js`。目前我们可以全部选择默认选项：

```
✔ Which style would you like to use? › New York
✔ Which color would you like to use as the base color? › Neutral
✔ Would you like to use CSS variables for theming? yes
```

## 添加首个组件

为了展示 shadcn 的强大功能，让我们直接开始创建一个全新的 **React Flow** 应用！现在一切准备就绪，只需一条命令即可添加 [`<BaseNode />`](/ui/components/base-node) 组件：

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/base-node
```

该命令将生成新文件 `src/components/base-node.tsx`，同时更新依赖项以包含 `@xyflow/react`！

这个 `<BaseNode />` 组件并非直接的 React Flow 节点。正如其名，它是其他许多节点的基础构建模块，同时还附带以下可用于定义节点头部和内容的子组件：

- `<BaseNodeHeader />`
- `<BaseNodeHeaderTitle />`
- `<BaseNodeContent />`
- `<BaseNodeFooter />`

你可以用它来为所有节点统一风格。让我们通过更新 `App.jsx` 文件来看看效果：

```jsx filename="src/App.jsx"
import '@xyflow/react/dist/style.css';

import { BaseNode } from '@/components/base-node';

function App() {
  return (
    <div className="w-screen h-screen p-8">
      <BaseNode>
        <BaseNodeHeader>
          <BaseNodeHeaderTitle>Base Node</BaseNodeHeaderTitle>
        </BaseNodeHeader>
        <BaseNodeContent>
          This is a base node component that can be used to build other nodes.
        </BaseNodeContent>
      </BaseNode>
    </div>
  );
}

export default App;
```

好吧，看起来并不特别惊艳...

<Image
  src="/img/tutorials/components/base-node.png"
  alt="A screenshot of a simple React application. It renders one element, a
  rounded container with a blue border and the text 'Hi! 👋' inside."
/>

请记住，`<BaseNode />` 组件会被我们通过 shadcn CLI 添加的任何_其他_ React Flow 组件所使用，那么如果我们修改它会发生什么？让我们更新 `<BaseNode />` 组件，使其将所有文本渲染为加粗等宽字体：

```jsx filename="src/components/base-node.tsx" {11}
import { cn } from "@/lib/utils";
import { forwardRef, HTMLAttributes } from "react";

export const BaseNode = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'relative rounded-md border bg-card text-card-foreground',
        'hover:ring-1',
        // React Flow displays node elements inside of a `NodeWrapper` component,
        // which compiles down to a div with a the class `react-flow__node`.
        // When a node is selected, the class `selected` is added to the
        // `react-flow__node` element. This allows us to style the node when it
        // is selected, using Tailwind's `&` selector.
        '[.react-flow\\_\\_node.selected_&]:border-muted-foreground',
        '[.react-flow\\_\\_node.selected_&]:shadow-lg',
        className,
      )}
      tabIndex={0}
      {...props}
    />
  ),
);
BaseNode.displayName = 'BaseNode';

/**
 * A container for a consistent header layout intended to be used inside the
 * `<BaseNode />` component.
 */
export const BaseNodeHeader = forwardRef<HTMLElement, HTMLAttributes<HTMLElement>>(
  ({ className, ...props }, ref) => (
    <header
      ref={ref}
      {...props}
      className={cn(
        'mx-0 my-0 -mb-1 flex flex-row items-center justify-between gap-2 px-3 py-2',
        // Remove or modify these classes if you modify the padding in the
        // `<BaseNode />` component.
        className,
      )}
    />
  ),
);
BaseNodeHeader.displayName = 'BaseNodeHeader';

/**
 * The title text for the node. To maintain a native application feel, the title
 * text is not selectable.
 */
export const BaseNodeHeaderTitle = forwardRef<
  HTMLHeadingElement,
  HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    data-slot="base-node-title"
    className={cn('user-select-none flex-1 font-semibold', className)}
    {...props}
  />
));
BaseNodeHeaderTitle.displayName = 'BaseNodeHeaderTitle';

export const BaseNodeContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-slot="base-node-content"
      className={cn('flex flex-col gap-y-2 p-3', className)}
      {...props}
    />
  ),
);
BaseNodeContent.displayName = 'BaseNodeContent';

export const BaseNodeFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-slot="base-node-footer"
      className={cn(
        'flex flex-col items-center gap-y-2 border-t px-3 pb-3 pt-2',
        className,
      )}
      {...props}
    />
  ),
);
BaseNodeFooter.displayName = 'BaseNodeFooter';

```

现在我们将从 React Flow UI 注册表中添加一个实际节点看看效果：

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/node-tooltip
```

接着更新 `App.tsx` 文件来渲染一个完整的流程图。我们将采用与大多数示例相同的基础配置，因此不再逐项拆解。如果你刚接触 React Flow 并想了解如何从零搭建基础流程图，请查阅我们的[快速入门指南](/learn)。

{/* TODO this could be linked to example app with RemoteCodeViewer editor */}

```tsx filename="src/App.tsx"
import React from 'react';
import { ReactFlow, type Node, Position, useNodesState } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

import {
  NodeTooltip,
  NodeTooltipContent,
  NodeTooltipTrigger,
} from './components/node-tooltip';
import { BaseNodeContent } from './components/base-node';

function Tooltip() {
  return (
    <NodeTooltip>
      <NodeTooltipContent position={Position.Top}>Hidden Content</NodeTooltipContent>
      <BaseNode>
        <BaseNodeContent>
          <NodeTooltipTrigger>Hover</NodeTooltipTrigger>
        </BaseNodeContent>
      </BaseNode>
    </NodeTooltip>
  );
}

const nodeTypes = {
  tooltip: Tooltip,
};

const initialNodes: Node[] = [
  {
    id: '1',
    position: { x: 0, y: 0 },
    data: {},
    type: 'tooltip',
  },
];

function Flow() {
  const [nodes, , onNodesChange] = useNodesState(initialNodes);

  return (
    <div className="h-screen w-screen p-8 bg-gray-50 rounded-xl">
      <ReactFlow
        nodes={nodes}
        nodeTypes={nodeTypes}
        onNodesChange={onNodesChange}
        fitView
      />
    </div>
  );
}
export function App() {
  return <Flow />;
}
```

看哪，我们添加的工具提示节点自动使用了我们自定义的 `<BaseNode />` 组件！

<RemoteCodeViewer route="tutorials/components/tooltip" framework="react" />

## 快速迭代与创造

现在我们已经基本理解 shadcn/ui 和 CLI 的工作原理，可以开始体会添加新组件和构建流程图是多么简单。为了展示 React Flow Components 的全部能力，让我们构建一个简单的计算器流程图。

首先移除 `<NodeTooltip />` 并撤销对 `<BaseNode />` 的修改。除了预制节点外，React Flow UI 还提供了构建自定义节点的组件模块。我们将添加 `labeled-handle` 组件来查看这些功能：

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/labeled-handle
```

我们要创建的第一个节点是简单的数值节点，包含增减数值的按钮和用于连接其他节点的连接点。创建文件夹 `src/components/nodes` 并添加新文件 `src/components/nodes/num-node.tsx`。

将以下代码粘贴到新文件中，并安装以下依赖项：

```bash copy npm2yarn
npx shadcn@latest add dropdown-menu button
```

```tsx filename="src/components/nodes/num-node.tsx"
import { type Node, type NodeProps, Position, useReactFlow } from '@xyflow/react';
import { useCallback } from 'react';

import {
  BaseNode,
  BaseNodeContent,
  BaseNodeFooter,
  BaseNodeHeader,
  BaseNodeHeaderTitle,
} from '@/components/base-node';
import { LabeledHandle } from '@/components/labeled-handle';

import { EllipsisVertical } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

export type NumNode = Node<{
  value: number;
}>;

export function NumNode({ id, data }: NodeProps<NumNode>) {
  const { updateNodeData, setNodes } = useReactFlow();

  const handleReset = useCallback(() => {
    updateNodeData(id, { value: 0 });
  }, [id, updateNodeData]);

  const handleDelete = useCallback(() => {
    setNodes((nodes) => nodes.filter((node) => node.id !== id));
  }, [id, setNodes]);

  const handleIncr = useCallback(() => {
    updateNodeData(id, { value: data.value + 1 });
  }, [id, data.value, updateNodeData]);

  const handleDecr = useCallback(() => {
    updateNodeData(id, { value: data.value - 1 });
  }, [id, data.value, updateNodeData]);

  return (
    <BaseNode>
      <BaseNodeHeader className="border-b">
        <BaseNodeHeaderTitle>Num</BaseNodeHeaderTitle>

        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              variant="ghost"
              className="nodrag p-1"
              aria-label="Node Actions"
              title="Node Actions"
            >
              <EllipsisVertical className="size-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuLabel>Node Actions</DropdownMenuLabel>
            <DropdownMenuItem onSelect={handleReset}>Reset</DropdownMenuItem>
            <DropdownMenuItem onSelect={handleDelete}>Delete</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </BaseNodeHeader>

      <BaseNodeContent>
        <div className="flex gap-2 items-center">
          <Button onClick={handleDecr}>-</Button>
          <pre>{String(data.value).padStart(3, ' ')}</pre>
          <Button onClick={handleIncr}>+</Button>
        </div>
      </BaseNodeContent>

      <BaseNodeFooter className="bg-gray-100 items-end px-0 py-1 w-full">
        <LabeledHandle title="out" type="source" position={Position.Right} />
      </BaseNodeFooter>
    </BaseNode>
  );
}
```

<Callout>
  本教程不涉及基础 React Flow 概念（如流程和自定义节点），因此**跳过部分基础知识**。如果你是 React Flow 新手并想学习如何向流程添加自定义节点和边，请参阅[自定义节点指南](/learn/customization/custom-nodes)。
</Callout>

在上面的代码片段中，我们高亮了来自 shadcn/ui 和 React Flow Components 的导入项和组件。仅用几行代码我们就实现了一个功能完备的节点：

<RemoteCodeViewer route="tutorials/components/num-node" framework="react" />

我们的 `<NumNode />` 组件...

- 具有带标题和功能下拉菜单的头部
- 包含用于增减数值的简单控件
- 带有标记连接点可与其他节点相连

接下来我们将创建第二个节点，用于计算两个输入值的和。这个节点不需要添加额外的组件，因此请直接新建文件 `src/components/nodes/sum-node.tsx` 并粘贴以下内容：

```tsx filename="src/components/nodes/sum-node.tsx"
import {
  type Node,
  type NodeProps,
  Position,
  useReactFlow,
  useStore,
} from '@xyflow/react';
import { useEffect } from 'react';

import { BaseNode, BaseNodeHeader, BaseNodeHeaderTitle } from '../base-node';
import { LabeledHandle } from '../labeled-handle';

export type SumNode = Node<{
  value: number;
}>;

export function SumNode({ id }: NodeProps<SumNode>) {
  const { updateNodeData, getHandleConnections } = useReactFlow();
  const { x, y } = useStore((state) => ({
    x: getHandleValue(
      getHandleConnections({ nodeId: id, id: 'x', type: 'target' }),
      state.nodeLookup,
    ),
    y: getHandleValue(
      getHandleConnections({ nodeId: id, id: 'y', type: 'target' }),
      state.nodeLookup,
    ),
  }));

  useEffect(() => {
    updateNodeData(id, { value: x + y });
  }, [x, y]);

  return (
    <BaseNode className="w-32">
      <BaseNodeHeader>
        <BaseNodeHeaderTitle>Sum</BaseNodeHeaderTitle>
      </BaseNodeHeader>

      <footer className="bg-gray-100">
        <LabeledHandle title="x" id="x" type="target" position={Position.Left} />
        <LabeledHandle title="y" id="y" type="target" position={Position.Left} />
        <LabeledHandle title="out" type="source" position={Position.Right} />
      </footer>
    </BaseNode>
  );
}

function getHandleValue(
  connections: Array<{ source: string }>,
  lookup: Map<string, Node<any>>,
) {
  return connections.reduce((acc, { source }) => {
    const node = lookup.get(source)!;
    const value = node.data.value;

    return typeof value === 'number' ? acc + value : acc;
  }, 0);
}
```

React Flow UI 不仅提供了构建节点的组件，还内置了预制的边线和其他 UI 元素，您可以直接拖入流程图中快速搭建。

为了更好地在计算器流程中可视化数据，我们将引入 `data-edge` 组件。该边线会将源节点数据对象中的字段渲染为边线上的标签。将 `data-edge` 组件添加到您的项目中：

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/data-edge
```

`<DataEdge />` 组件的工作原理是从源节点的 `data` 对象中查找字段。我们一直在计算器字段的 `"value"` 属性中存储每个节点的值，因此需要更新 `edgeType` 对象以包含新的 `data-edge`，同时更新 `onConnect` 处理程序来创建这种类型的新边线，并确保正确设置边线的 `data` 对象：

```tsx filename="src/App.tsx"
import '@xyflow/react/dist/style.css';

import {
  ReactFlow,
  OnConnect,
  Position,
  useNodesState,
  useEdgesState,
  addEdge,
  Edge,
  Node,
} from '@xyflow/react';

import { NumNode } from '@/components/nodes/num-node';
import { SumNode } from '@/components/nodes/sum-node';

import { DataEdge } from '@/components/data-edge';

const nodeTypes = {
  num: NumNode,
  sum: SumNode,
};

const initialNodes: Node[] = [
  { id: 'a', type: 'num', data: { value: 0 }, position: { x: 0, y: 0 } },
  { id: 'b', type: 'num', data: { value: 0 }, position: { x: 0, y: 200 } },
  { id: 'c', type: 'sum', data: { value: 0 }, position: { x: 300, y: 100 } },
  { id: 'd', type: 'num', data: { value: 0 }, position: { x: 0, y: 400 } },
  { id: 'e', type: 'sum', data: { value: 0 }, position: { x: 600, y: 400 } },
];

const edgeTypes = {
  data: DataEdge,
};

const initialEdges: Edge[] = [
  {
    id: 'a->c',
    type: 'data',
    data: { key: 'value' },
    source: 'a',
    target: 'c',
    targetHandle: 'x',
  },
  {
    id: 'b->c',
    type: 'data',
    data: { key: 'value' },
    source: 'b',
    target: 'c',
    targetHandle: 'y',
  },
  {
    id: 'c->e',
    type: 'data',
    data: { key: 'value' },
    source: 'c',
    target: 'e',
    targetHandle: 'x',
  },
  {
    id: 'd->e',
    type: 'data',
    data: { key: 'value' },
    source: 'd',
    target: 'e',
    targetHandle: 'y',
  },
];

function App() {
  const [nodes, , onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  const onConnect: OnConnect = useCallback(
    (params) => {
      setEdges((edges) =>
        addEdge({ type: 'data', data: { key: 'value' }, ...params }, edges),
      );
    },
    [setEdges],
  );

  return (
    <div className="h-screen w-screen p-8">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        fitView
      />
    </div>
  );
}

export default App;
```

将所有组件整合后，我们就得到了一个功能相当完善的小型计算器！

<RemoteCodeViewer route="tutorials/components/complete" framework="react" />

您可以继续完善这个流程图，通过添加节点来执行其他操作，或者使用 [shadcn/ui 组件库](https://ui.shadcn.com/docs/components/slider) 中的额外组件来接收用户输入。事实上，请密切关注本教程的后续内容，我们将展示一个使用 React Flow Components 构建的完整应用 <Emoji content="👀" />。

## 总结

在短短时间内，我们利用 shadcn React Flow Components 提供的组件和构建模块，成功搭建了一个相当完整的流程图。我们学到了：

- 如何通过编辑 [`<BaseNode />`](/ui/components/base-node) 组件来影响从 React Flow UI 注册表中提取的其他节点

- 如何使用 [`<BaseNodeHeader />`](/ui/components/base-node) 和 [`<LabeledHandle />`](/ui/components/labeled-handle) 等构建模块组件，无需从零开始就能创建自定义节点

- React Flow UI 还提供了像 [`<DataEdge />`](/ui/components/data-edge) 这样的自定义边线组件，可直接集成到应用中

得益于 Tailwind 的强大功能，调整这些组件的视觉样式就像编辑 `tailwind.config.js` 和修改 CSS 文件中的变量一样简单。

目前就介绍到这里！您可以在 [UI 文档页面](/ui) 查看我们当前提供的所有组件。React Flow UI 项目仍处于早期阶段：如果您有任何新组件的建议或需求，我们非常乐意听取。或者您可能已经开始使用 shadcn 和 React Flow UI 构建项目了。无论哪种情况，都欢迎通过我们的 [Discord 服务器](https://discord.com/invite/RVmnytFmGW) 或 [Twitter](https://twitter.com/xyflowdev) 联系我们！