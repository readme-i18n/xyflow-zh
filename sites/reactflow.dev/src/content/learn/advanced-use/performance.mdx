---

description: 针对大型图表优化 React Flow 性能的策略
---

# 性能优化

当处理大量节点或复杂组件时，性能管理可能颇具挑战性。以下是优化 React Flow 性能的几种有效策略。

## 使用记忆化

React Flow 性能问题的主要原因之一是不必要的重新渲染。由于节点移动会触发频繁的状态更新，这可能导致性能瓶颈，特别是在大型图表中。

### 记忆化组件

作为 props 传递给 `<ReactFlow>` 组件的元素（包括自定义节点和边组件），应当使用 `React.memo` 进行记忆化或在父组件外部声明。这能确保 React 不会在每次渲染时为组件创建新的引用，否则会触发不必要的重新渲染。

```tsx
const NodeComponent = memo(() => {
  return <div>{data.label}</div>;
});
```

### 记忆化函数

同理，传递给 `<ReactFlow>` 的函数 props 应当使用 `useCallback` 进行记忆化。这能防止 React 在每次渲染时创建新的函数引用，从而避免不必要的重新渲染。此外，像 `defaultEdgeOptions` 或 `snapGrid` 这样的数组和对象也应使用 `useMemo` 进行记忆化。

```tsx
import React, { useCallback } from 'react';

const MyDiagram = () => {
  const onNodeClick = useCallback((event, node) => {
    console.log('Node clicked:', node);
  }, []);

  return <ReactFlow onNodeClick={onNodeClick} />;
};

export default MyDiagram;
```

## 避免在组件中访问节点

React Flow 中最常见的性能陷阱之一是在组件或视口中直接访问 `nodes` 或 `edges` 对象。这些对象在拖拽、平移或缩放等操作期间会频繁变化，可能导致依赖它们的组件不必要地重新渲染。

例如，若从存储中获取整个 `nodes` 数组并过滤它以显示选中的节点 ID，这种做法会导致性能下降。每次 `nodes` 数组的更新都会触发所有依赖组件的重新渲染，即使变更与选中节点无关。

### 低效示例

```tsx
const SelectedNodeIds = () => {
  // ❌ This will cause unnecessary re-renders!

  const nodes = useStore((state) => state.nodes);

  const selectedNodeIds = nodes.filter((node) => node.selected).map((node) => node.id);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

此示例中，每次 `nodes` 数组的更新都会导致 `SelectedNodeIds` 组件重新渲染，即使选中状态并未改变。

### 优化方案

为避免不必要的重新渲染，请将选中节点存储在状态的独立字段中（使用 Zustand、Redux 或其他状态管理方案）。这能确保组件仅在选中状态变化时重新渲染。

```tsx
const SelectedNodeIds = () => {
  const selectedNodeIds = useStore((state) => state.selectedNodeIds);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

通过将选中节点与 `nodes` 数组解耦，可避免不必要的更新并提升性能。更多信息请参阅[状态管理指南](/learn/advanced-use/state-management)。

## 折叠大型节点树

如果节点树层级过深，一次性渲染所有节点会导致效率低下。  
此时应仅展示有限数量的节点，并允许用户按需展开。您可以通过动态修改节点的 `hidden` 属性来实现显隐切换。

```tsx
const handleNodeClick = (targetNode) => {
  if (targetNode.data.children) {
    setNodes((prevNodes) =>
      prevNodes.map((node) =>
        targetNode.data.children.includes(node.id)
          ? { ...node, hidden: !node.hidden }
          : node,
      ),
    );
  }
};
```

通过初始隐藏节点并在展开时渲染，我们能在保持可用性的同时优化性能。

## 简化节点与边的样式

若已尝试其他优化手段，但大量节点仍存在性能问题，请注意复杂的 CSS 样式（特别是涉及动画、阴影或渐变的样式）会显著影响性能。此时应考虑简化节点样式。

## 扩展资源

以下是与 React Flow 性能优化相关的实用资源：

- [Guide to Optimize React Flow Project Performance](https://www.synergycodes.com/blog/guide-to-optimize-react-flow-project-performance)
- [Tuning Edge Animations ReactFlow Optimal Performance](https://liambx.com/blog/tuning-edge-animations-reactflow-optimal-performance)
- [5 Ways to Optimize React Flow in 10 minutes](https://www.youtube.com/watch?v=8M2qZ69iM20)