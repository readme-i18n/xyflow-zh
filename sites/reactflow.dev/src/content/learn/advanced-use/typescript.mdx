---

sidebarTitle: TypeScript
description: 本指南将介绍如何结合 React Flow 与 TypeScript 进行开发。
---

import { Callout } from 'nextra/components';

# TypeScript 使用指南

React Flow 采用 TypeScript 编写，因为我们重视其提供的额外类型安全保障。我们导出了所有必要的类型定义，用于正确标注传递给 React Flow 组件的数据结构和函数。同时，我们也支持扩展节点(node)和连线(edge)的类型定义。

## 基础用法

让我们从最基础的类型开始，这些是简单入门所需的核心类型。虽然 TypeScript 可能已能推断部分类型，但我们仍会显式定义它们。

```tsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  applyNodeChanges,
  applyEdgeChanges,
  type Node,
  type Edge,
  type FitViewOptions,
  type OnConnect,
  type OnNodesChange,
  type OnEdgesChange,
  type OnNodeDrag,
  type DefaultEdgeOptions,
} from '@xyflow/react';

const initialNodes: Node[] = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 5, y: 5 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 5, y: 100 } },
];

const initialEdges: Edge[] = [{ id: 'e1-2', source: '1', target: '2' }];

const fitViewOptions: FitViewOptions = {
  padding: 0.2,
};

const defaultEdgeOptions: DefaultEdgeOptions = {
  animated: true,
};

const onNodeDrag: OnNodeDrag = (_, node) => {
  console.log('drag event', node.data);
};

function Flow() {
  const [nodes, setNodes] = useState<Node[]>(initialNodes);
  const [edges, setEdges] = useState<Edge[]>(initialEdges);

  const onNodesChange: OnNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    [setNodes],
  );
  const onEdgesChange: OnEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    [setEdges],
  );
  const onConnect: OnConnect = useCallback(
    (connection) => setEdges((eds) => addEdge(connection, eds)),
    [setEdges],
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
      onNodeDrag={onNodeDrag}
      fitView
      fitViewOptions={fitViewOptions}
      defaultEdgeOptions={defaultEdgeOptions}
    />
  );
}
```

### 自定义节点

当使用[自定义节点](/learn/customization/custom-nodes)时，你可以向 `NodeProps` 类型传递自定义的 `Node` 类型（或你的 `Node` 联合类型）。处理自定义节点主要有两种方式：

1. 若存在**多个自定义节点**，需将特定的 `Node` 类型作为泛型参数传递给 `NodeProps` 类型：

```tsx filename="NumberNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;

export default function NumberNode({ data }: NodeProps<NumberNode>) {
  return <div>A special number: {data.number}</div>;
}
```

⚠️ 若单独定义节点数据，必须使用 `type` 关键字（此处不能使用 `interface`）：

```ts
type NumberNodeData = { number: number };
type NumberNode = Node<NumberNodeData, 'number'>;
```

2. 若存在**单一自定义节点**但需根据节点类型渲染不同内容，应将 `Node` 联合类型作为泛型参数传递给 `NodeProps`：

```tsx filename="CustomNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;
type TextNode = Node<{ text: string }, 'text'>;

type AppNode = NumberNode | TextNode;

export default function CustomNode({ data }: NodeProps<AppNode>) {
  if (data.type === 'number') {
    return <div>A special number: {data.number}</div>;
  }

  return <div>A special text: {data.text}</div>;
}
```

### 自定义连线

对于[自定义连线](/learn/customization/custom-nodes)，其类型处理方式与自定义节点相同。

```tsx filename="CustomEdge.tsx"
import { getStraightPath, BaseEdge, type EdgeProps, type Edge } from '@xyflow/react';

type CustomEdge = Edge<{ value: number }, 'custom'>;

export default function CustomEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
}: EdgeProps<CustomEdge>) {
  const [edgePath] = getStraightPath({ sourceX, sourceY, targetX, targetY });

  return <BaseEdge id={id} path={edgePath} />;
}
```

## 高级用法

在使用 React Flow 创建复杂应用时，您会拥有多个自定义节点和边，每个元素都关联着不同类型的数据。当我们通过内置函数和钩子操作这些节点和边时，必须确保通过[类型收窄](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)来明确节点与边的类型，以避免运行时错误。

### `Node` 和 `Edge` 类型联合

您会看到许多函数、回调和钩子（甚至 ReactFlow 组件本身）需要接收 `NodeType` 或 `EdgeType` 泛型。这些泛型本质上就是应用中所有节点与边类型的[联合类型](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)。只要您正确声明了数据对象的类型（参见前一节），就可以直接使用它们导出的类型。

<Callout type="info">
  如果使用任何内置节点（'input'、'output'、'default'）或边类型（'straight'、'step'、'smoothstep'、'bezier'），可以将 `@xyflow/react` 导出的 `BuiltInNode` 和 `BuiltInEdge` 类型添加到您的联合类型中。
</Callout>

```tsx
import type { BuiltInNode, BuiltInEdge } from '@xyflow/react';

// Custom nodes
import NumberNode from './NumberNode';
import TextNode from './TextNode';

// Custom edge
import EditableEdge from './EditableEdge';

export type CustomNodeType = BuiltInNode | NumberNode | TextNode;
export type CustomEdgeType = BuiltInEdge | EditableEdge;
```

### 传递给 `<ReactFlow />` 的函数

要为回调函数获取正确的类型，您可以将联合类型传递给 `ReactFlow` 组件。这样做需要显式声明回调函数的类型。

```tsx
import { type OnNodeDrag } from '@xyflow/react';

// ...

// Pass your union type here ...
const onNodeDrag: OnNodeDrag<CustomNodeType> = useCallback((_, node) => {
  if (node.type === 'number') {
    // From here on, Typescript knows that node.data
    // is of type { num: number }
    console.log('drag event', node.data.number);
  }
}, []);

const onNodesChange: OnNodesChange<CustomNodeType> = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```

### 钩子

类型联合同样可用于声明多个钩子的返回值类型。

```tsx filename="FlowComponent.tsx"
import { useReactFlow, useNodeConnections, useNodesData, useStore } from '@xyflow/react';

export default function FlowComponent() {
  // returned nodes and edges are correctly typed now
  const { getNodes, getEdges } = useReactFlow<CustomNodeType, CustomEdgeType>();

  // You can type useStore by typing the selector function
  const nodes = useStore((s: ReactFlowState<CustomNodeType>) => ({
    nodes: s.nodes,
  }));

  const connections = useNodeConnections({
    handleType: 'target',
  });

  const nodesData = useNodesData<CustomNodeType>(connections?.[0].source);

  nodeData.forEach(({ type, data }) => {
    if (type === 'number') {
      // This is type safe because we have narrowed down the type
      console.log(data.number);
    }
  });
  // ...
}
```

### 类型守卫

在 TypeScript 中，有[多种方式](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)可以定义类型守卫。其中一种方法是定义类型守卫函数，例如 `isNumberNode` 或 `isTextNode`，用于从节点列表中筛选出特定类型的节点。

```tsx
function isNumberNode(node: CustomNodeType): node is NumberNode {
  return node.type === 'number';
}

// numberNodes is of type NumberNode[]
const numberNodes = nodes.filter(isNumberNode);
```